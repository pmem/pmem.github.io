---
title: MemKeyDB - Redis with Persistent Memory
author: jschmieg
layout: post
identifier: memkeydb
---


# Context

Redis is in-memory database that supports many different data-structures and stores them in main memory. To support data durability Redis relies on creating periodical snapshots of dataset or logging all commands that are reaching server. 

When persistent memory started to appear, we started working on various approaches to using it in Redis. Apart from using its persistence, we also had at our disposal its huge capacity.

Our first approaches focused on the replacement of the internal mechanisms of Redis' persistence by the persistency of the medium. However, we have concluded that the exclusion of these functions can be negatively perceived by current users, all the more so because the snapshot creation mechanism is also used by the remote data replication mechanism. On the other hand, Redis uses a copy-on-write mechanism to generate database snapshots, which behavior on FS-DAX is problematic, and causes transparent data migration from the PMEM to DRAM: parent process is modifying data in PMEM, at the same time as child process is reading it. Copy-on-write mechanism duplicates pages before modification and allocates their copies in DRAM. In order to solve this, we have tried various workarounds such as: adopting kind of lazy-free mechanism and other ways to not trigger data modification during Redis fork(). The result was a complex modification of the application, which occurred in many places in the code.

The situation became much simpler when the Linux kernel 5.1 included support for the [KMEM DAX](https://patchwork.kernel.org/cover/10829019/) mechanism and the possibility of exposing memory from the device as an additional NUMA node. Using this feature, support for Copy-on-Write was transparent and the memory pages modified during the fork() were allocated from the same NUMA node to which the parent process was bound. Support for this mechanism has been added in our volatile memory allocator – [Memkind](https://pmem.io/2020/01/20/libmemkind.html) as an additional [static kind](https://pmem.io/2020/01/20/memkind-dax-kmem.html).

Having the above described possibilities, we modified Redis by adding a new type of memory used in a volatile way, while leaving the native mechanisms of persistence: AOF and RDB. At the same time, we collected functional requirements from clients and created a community around the project on github: [MemKeyDB](https://github.com/memKeyDB/memKeyDB).

# Technical description

Antirez’ Redis uses jemalloc to allocate memory for the application. In MemKeyDB it was replaced with Memkind allocator which is based on jemalloc. It manages allocations from DRAM and PMEM by introducing the idea of memory kinds. Separate “malloc” calls are used to allocate from both mediums. To simplify code modification, it is very convenient to use another Memkind feature which is “free” call common for every memory kind. Allocator itself can identify which memory was used for a given pointer and free it properly. This allows us to modify only the “allocation” part for a given structure without the need of tracking origins of allocation until “free” is called.
```c
memkind_free(NULL, ptr);
```
Having two types of memories in the application, we used the size of the allocation as a criterion for choosing which one to use. Structures whose size is above a certain threshold are to be allocated from PMEM as the larger medium and smaller from DRAM:
```c
void *zmalloc(size_t size) {
    return (size < pmem_threshold) ? zmalloc_dram(size) : zmalloc_pmem(size);
}
```
The proportion of DRAM and PMEM utilization is user configurable by defining DRAM/PMEM ratio parameter and allows to select the best value for current hardware and workload type. The dynamic threshold mechanism controls the location of data. It monitors allocator statistics related to DRAM and PMEM and periodically adjusts the internal dynamic threshold. This balances utilization of each media to be close to the target value configured for the application. The algorithm also checks the rate and trend of the current DRAM/PMEM ratio to speed-up reaching the desired ratio.

# Redis Optimizations

Besides user data for storing keys and values, the application uses a lot of internal structures. They are frequently allocated and deallocated, e.g. when a new client connects to the Redis server. As they are used as temporary structures with limited total size compared to user data, they don’t affect DRAM / PMEM ratio. For performance reason is it worth to always allocate them on DRAM. This is done with simple code modification for “client” structure and a lot of its side structures e.g. buffers used for storing incoming data or used for creating a list of objects to send to the client.

![Client optimization](/assets/memkeydb_client.png)

Other structures are metadata that are describing user data. They are usually very small comparing to keys and values but may influence performance when stored on PMEM. There were introduced code optimizations related to:
* Storing Redis object structure (robj) always in DRAM (except Embedded Strings).
* Storing Main Redis Hashtable by default in DRAM. As the size of hashtable may be significant for scenarios when the dataset contains mostly small objects, there is a configuration option that allows to change the placement of the main hashtable to PMEM.

For structures that are optimized to always be allocated from DRAM, a good idea is to pass this information to Memkind allocator. This eliminates the needs of identification where it was allocated from and speeds up the execution.

# Memkind optimizations

Memkind is general-purpose allocator, but for an application like Redis it was also optimized by passing specific parameters during “configure” part:
* The number of arenas – for PMEM kinds Memkind usually creates 4 x CPU arenas. For a single-threaded application, it can be limited to 1 arena. This speeds up scenarios when allocator statistics are gathered by iterating through all arenas.
* Lg_quantum – inherits the value from jemalloc config in Redis. Creates an addition allocation class which is very often used by Redis. This helps to increase memory utilization.

# Project location

Project is available here:
[https://github.com/memKeyDB/memKeyDB](https://github.com/memKeyDB/memKeyDB).

