<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pmdk on PMem.io</title><link>https://pmem.io/blogs/pmdk/</link><description>Recent content in pmdk on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 30 Jun 2022 10:00:00 +0000</lastBuildDate><atom:link href="https://pmem.io/blogs/pmdk/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction to libpmem2 (part 1)</title><link>https://pmem.io/blog/2022/06/introduction-to-libpmem2-part-1/</link><pubDate>Thu, 30 Jun 2022 10:00:00 +0000</pubDate><guid>https://pmem.io/blog/2022/06/introduction-to-libpmem2-part-1/</guid><description>A new beginning This blog post will be about the recently created library libpmem2, which is a part of PMDK repository. Before we go into details it&amp;rsquo;s worth having a short look at the history. About seven years ago, the first persistent memory library known as libpmem was started. The concept of persistent memory was becoming a reality. Initially, libpmem provided simple support for memory memory management on pmem. Over time, the development of hardware, software, as well as changing customer needs made it necessary to evolve the library to include new features such as support for Windows, DevDax, RAS, eADR, and others.</description></item><item><title>Memory Tiering (part 1)</title><link>https://pmem.io/blog/2022/06/memory-tiering-part-1/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate><guid>https://pmem.io/blog/2022/06/memory-tiering-part-1/</guid><description>Extending memory capacity with PMEM Databases such as Redis (an in-memory key-value open-source database) consume a lot of memory. Since fast access is essential for them, they use DRAM to store their data. DRAM is quite expensive and has limited capacity, so a solution we propose in this blog post is to use PMEM (and in the future other types of memory available through CXL - see a pmem.io blog post about it).</description></item><item><title>Basic asynchronous hashmap with Miniasync library</title><link>https://pmem.io/blog/2022/06/basic-asynchronous-hashmap-with-miniasync-library/</link><pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate><guid>https://pmem.io/blog/2022/06/basic-asynchronous-hashmap-with-miniasync-library/</guid><description>Miniasync library provides a framework for the composition and execution of asynchronous tasks in C. To accommodate different user-defined tasks and various types of data that they take in, libminiasync makes use of macros.
Using libminiasync for the first time can be challenging. There are multiple examples on the miniasync repo to make it easier. One of them is a hashmap example.
Hashmap example overview The hashmap example on the Miniasync repository presents a hashmap with a fixed size that allocates memory upon key-value pair insertion.</description></item><item><title>Upcoming asynchronous interfaces in PMDK libraries</title><link>https://pmem.io/blog/2022/05/upcoming-asynchronous-interfaces-in-pmdk-libraries/</link><pubDate>Wed, 11 May 2022 10:00:00 +0000</pubDate><guid>https://pmem.io/blog/2022/05/upcoming-asynchronous-interfaces-in-pmdk-libraries/</guid><description>In the previous article, I wrote about a new upcoming Xeon platform feature, Data Streaming Accelerator (DSA) - a memory-to-memory DMA engine, and what opportunities and challenges it presents. I outlined the approach we are taking in Persistent Memory Development Kit (PMDK) to expose asynchronous APIs that can take advantage of this new hardware. Lastly, I introduced libminiasync, which is our framework for abstracting asynchronous operations.
This time, I will discuss how miniasync is being used in libpmem2 and our plans for its integration into the rest of PMDK libraries.</description></item><item><title>Leveraging asynchronous hardware accelerators for fun and profit</title><link>https://pmem.io/blog/2022/02/leveraging-asynchronous-hardware-accelerators-for-fun-and-profit/</link><pubDate>Mon, 28 Feb 2022 10:00:00 +0000</pubDate><guid>https://pmem.io/blog/2022/02/leveraging-asynchronous-hardware-accelerators-for-fun-and-profit/</guid><description>One of the greatest benefits of Persistent Memory is that it&amp;rsquo;s directly accessible by the CPU. But that can also be one of its downsides for specific use cases. For example, if you want to use PMem as an ultra-fast storage device with low access latency.
PMem as storage impedance mismatch The reason for that is simple - block storage I/O is typically asynchronous due to its relatively high latency and high queue depths required to reach optimal throughputs.</description></item><item><title>Disaggregated Memory - In pursuit of scale and efficiency</title><link>https://pmem.io/blog/2022/01/disaggregated-memory-in-pursuit-of-scale-and-efficiency/</link><pubDate>Fri, 21 Jan 2022 10:00:00 +0100</pubDate><guid>https://pmem.io/blog/2022/01/disaggregated-memory-in-pursuit-of-scale-and-efficiency/</guid><description>A software person perspective on new upcoming interconnect technologies.
Existing Server Landscape Servers are expensive. And difficult to maintain properly. That&amp;rsquo;s why most people turn to the public cloud for their hosting and computing needs. Dynamic virtual server instances have been key to unlocking efficiency gains for both Cloud Service Providers (CSPs) and their users. CSPs can leverage virtualization to colocate many workloads on fewer physical servers. And cloud users have access to a huge pool of on-demand processing power, only having to pay for what they use.</description></item><item><title>Static code analysis of the PMDK</title><link>https://pmem.io/blog/2020/08/static-code-analysis-of-the-pmdk/</link><pubDate>Thu, 20 Aug 2020 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2020/08/static-code-analysis-of-the-pmdk/</guid><description>Introduction In the PMDK team, we focus on the quality of our codebase. One of the standard practices in the software development is a static code analysis, which improves the overall project quality and fixes bugs in the early stage of development. Since there is no silver bullet for avoiding bugs, we already use two different static analysis tools and many runtime checkers e.g. valgrind. Improving static analysis effectiveness is a separate academic problem.</description></item><item><title>New release of PMDK</title><link>https://pmem.io/blog/2019/10/new-release-of-pmdk/</link><pubDate>Fri, 11 Oct 2019 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2019/10/new-release-of-pmdk/</guid><description>If you are following our mailing group, you&amp;rsquo;ve probably noticed a stream of release announcements for libraries that are a part of PMDK. Here&amp;rsquo;s a recap of the most important new features and additions.
libpmemkv 1.0 The primary goal of PMDK is enabling adoption of Persistent Memory. We do so by creating the building blocks that applications can utilize to support PMEM. So far, our work was mostly concentrated on important base functionality such as memory allocation or transactions, and only recently we&amp;rsquo;ve started to build on that foundation with C++ containers - making persistent memory programming easier and easier.</description></item><item><title>Pool conversion tool</title><link>https://pmem.io/blog/2019/02/pool-conversion-tool/</link><pubDate>Fri, 01 Feb 2019 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2019/02/pool-conversion-tool/</guid><description>Introduction When we published the first PMDK stable release, we committed to maintaining stable on-media layout. This means that all future PMDK changes have to be backward compatible. Unfortunately, we weren&amp;rsquo;t successful in adhering to the strict requirements which would be needed to maintain compatibility, mostly because we made changes whose benefit far outweighed the costs. For this reason, we created the pmempool convert command. This tool was used to convert pools which were created with old PMDK versions to the newer on-media layout.</description></item><item><title>New release of PMDK</title><link>https://pmem.io/blog/2018/10/new-release-of-pmdk/</link><pubDate>Mon, 22 Oct 2018 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2018/10/new-release-of-pmdk/</guid><description>We&amp;rsquo;ve been very quiet on this blog as of late, mostly because of the amount of work that we needed to put into our very ambitiously planned 1.5 release. But we&amp;rsquo;ve made it, and there&amp;rsquo;s finally time to get back to discussing the technical minutiae of our work. In this post, we will go over the major library changes that have been introduced in 1.5.
Release planning in the open But first, I&amp;rsquo;d like to highlight a change to our release planning process.</description></item><item><title>Announcing the Persistent Memory Development Kit</title><link>https://pmem.io/blog/2017/12/announcing-the-persistent-memory-development-kit/</link><pubDate>Mon, 11 Dec 2017 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2017/12/announcing-the-persistent-memory-development-kit/</guid><description>This is to announce a name change: The NVML project is now known as PMDK, the Persistent Memory Development Kit.
Why the name change? The old name, NVML, made it sound like the project produced a single library that applied to Non-Volatile Memory. In reality, the project currently supports ten libraries, targeted at various use cases for persistent memory, along with language support for C, C++, Java, and Python, tools like the pmemcheck plug-in for valgrind, and an increasing body of documentation, code examples, tutorials, and blog entries.</description></item><item><title>PMDK for Windows</title><link>https://pmem.io/blog/2016/12/pmdk-for-windows/</link><pubDate>Wed, 21 Dec 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/12/pmdk-for-windows/</guid><description>Throughout 2016 a team of engineers from Microsoft, Intel, HPE and HPI have been working to port the PMDK project to Windows and we are happy to announce that Technical Preview release is now available!
Our main goal in porting the library was to make it as easy as possible for developers to use the library in both Linux and Windows environments. To meet this goal, we focused on these elements as we undertook the effort:</description></item><item><title>NVM Library Overview</title><link>https://pmem.io/blog/2014/09/nvm-library-overview/</link><pubDate>Mon, 01 Sep 2014 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2014/09/nvm-library-overview/</guid><description>[Edit on 2017-12-11: In the years since this entry was written, this work has evolved into PMDK.] Why are we building an NVM Library? Where does it live? How does it work? This blog entry provides some answers, which refer to this picture showing the overall library architecture:
Why? The operating system exposes persistent memory to applications as a memory-mapped file, using a persistent memory aware file system as shown in the picture.</description></item></channel></rss>