<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Memkind on PMem.io</title><link>https://pmem.io/blogs/memkind/</link><description>Recent content in Memkind on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 12 May 2021 19:55:17 -0700</lastBuildDate><atom:link href="https://pmem.io/blogs/memkind/index.xml" rel="self" type="application/rss+xml"/><item><title>Memkind support for heterogeneous memory attributes</title><link>https://pmem.io/blog/2021/05/memkind-support-for-heterogeneous-memory-attributes/</link><pubDate>Wed, 12 May 2021 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2021/05/memkind-support-for-heterogeneous-memory-attributes/</guid><description>Introduction Memkind is a library mostly associated with enabling Persistent Memory. However, it is not the only type of memory that memkind supports. The library is a general solution designed for platforms with heterogeneous memory.
But before we delve into heterogeneous memory itself, let&amp;rsquo;s start with a short recap about NUMA. The NUMA concept solved the problem of a dynamic extension of the CPU count per socket and system memory. Before NUMA, Uniform Memory Access (UMA) was a common model, in which all processors shared physical memory uniformly.</description></item><item><title>Using Memkind in Hazelcast</title><link>https://pmem.io/blog/2021/02/using-memkind-in-hazelcast/</link><pubDate>Thu, 11 Feb 2021 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2021/02/using-memkind-in-hazelcast/</guid><description>This blog post is published on the Hazelcast blog as well. If interested in Hazelcast, check the other posts there too.
Introduction The mission of the PMDK team has always been and will always be to make programming persistent memory easier for the community of software developers. One of our goals is to help simplify the integration of persistent memory into software solutions by making it transparent as possible. Adopting ground-breaking and disruptive technology creates a chasm, which is challenging to cross at first.</description></item><item><title>Introduction to libmemkind</title><link>https://pmem.io/blog/2020/01/introduction-to-libmemkind/</link><pubDate>Mon, 20 Jan 2020 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2020/01/introduction-to-libmemkind/</guid><description>Introduction Memkind is the library that simplify usage of persistent memory in a volatile mode. There are NVDIMMs technologies, such as Intel Optane DCPMM, that provides persistency, byte-addressability, and also a high capacity when compared with DRAM modules. They can be used as an expansion of main memory and utilized by applications which consume a large amount of memory and do not require persistency, such as in-memory databases, caching engines and scientific simulations.</description></item><item><title>Memkind support for KMEM DAX option</title><link>https://pmem.io/blog/2020/01/memkind-support-for-kmem-dax-option/</link><pubDate>Mon, 20 Jan 2020 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2020/01/memkind-support-for-kmem-dax-option/</guid><description>Introduction Linux kernel version 5.1 brings in support for the volatile-use of persistent memory as a hotplugged memory region (KMEM DAX). When this feature is enabled, persistent memory is seen as a separate memory-only NUMA node(s). libmemkind API was extended to include new kinds that allow for automatic detection and allocation from these new persistent memory NUMA nodes.
Requirements 1. Kernel 5.1 with KMEM DAX driver enabled.
If support of KMEM DAX driver isn&amp;rsquo;t enabled in your kernel you will have to configure proper driver installation by run nconfig and enable driver.</description></item></channel></rss>