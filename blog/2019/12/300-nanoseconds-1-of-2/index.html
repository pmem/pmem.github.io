<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="300 nanoseconds (1 of 2)"><meta property="og:description" content="Educating people has always been a challenge for me. I tend to skip over things I wrongly consider obvious, or do large leaps in reasoning when explaining a solution to a problem. And so, when faced with an attempt to explain a complex topic, I tend to ramble on and on, hoping that the audience knows when to interrupt me if I go too fast. However, this doesn&rsquo;t hold true for blog posts, such as the one I&rsquo;m currently writing."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/blog/2019/12/300-nanoseconds-1-of-2/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-12-19T19:55:17-07:00"><meta property="article:modified_time" content="2019-12-19T19:55:17-07:00"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>300 nanoseconds (1 of 2)</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=content><div class="content-wrap dark-mode"><div class="container clearfix"><div class="row gutter-40 col-mb-80"><div class="postcontent col-lg-9 order-lg-last"><div class="single-post mb-0"><div class="entry clearfix"><div class=entry-title><h2>300 nanoseconds (1 of 2)</h2></div><div class=entry-meta><ul><li><i class=icon-calendar3></i> 19 Dec, 2019</li><li><i class=icon-user></i> Pbalcer</li><li><i class=icon-folder-open></i>
Perf300</li></ul></div><div class="entry-content mt-0"><p>Educating people has always been a challenge for me. I tend to skip over things
I wrongly consider obvious, or do large leaps in reasoning when explaining a
solution to a problem. And so, when faced with an attempt to explain a complex
topic, I tend to ramble on and on, hoping that the audience knows when to interrupt
me if I go too fast. However, this doesn&rsquo;t hold true for blog posts, such as the one I&rsquo;m
currently writing. This is why I have a request to you, the reader,
please do let me know if I went too fast on this one - thanks!</p><p>So, why did I write this seemingly off-topic preamble? I&rsquo;ve been trying to create
a write up about performance in persistent memory programming and why it&rsquo;s difficult.
And my immediate thought was that it really is not and you should just follow
the same old common sense rules you would for normal programs. It is just memory
after all, but with higher access latency. But then, when I look back at the
development history of libpmemobj, our memory allocator and transaction system,
and the performance improvements we&rsquo;ve made since the first version, I&rsquo;m
suddenly not so sure.</p><p><img src=/images/posts/300n_perf.png alt=map_insert></p><p>After all, if writing high-performance code for persistent memory were easy,
we&rsquo;d get it at least somewhat right the first time around. It&rsquo;s either that
or we were not as skilled as we thought we were back then. That&rsquo;s certainly
not beyond the realms of possibility for me, but the rest of my team? They are
definitely quality folks. So&mldr; at an attempt to save face, we will operate on
the assumption that my first instinct was wrong, and that crafting performant
persistent memory code is hard after all.</p><p>What follows is my attempt at explaining why that is the case and how we&rsquo;ve
learned that the hard way during development of libpmemobj.</p><h2 id=what-is-persistent-memory>What is Persistent Memory?</h2><p>But before we dive into the nitty-gritty details around performance, we first
need to define what persistent memory is. I wish it were easy to do&mldr;</p><p>Depending on who you ask, you might get a different answer. The broadest
definition that we commonly use is that it&rsquo;s memory that is non-volatile and has
access latency low enough that it is reasonable to stall the CPU while waiting
for reads or writes to complete.</p><p>But that definition is so broad that, if we were to operate only within its
constraints, it would make discussions around performance rather shallow and
limited to the non-volatile aspect of persistent memory.
In retrospect, this is one of the mistakes we&rsquo;ve made when first designing the
algorithms and data structures for PMDK. More on that later.</p><p>A more narrow answer is that persistent memory can be defined as a new class of
memories, best characterized by a product X from company Y.
For example, if you were to ask me, a paid Intel shill, what is this
persistent memory thing, my answer would have to be: May I interest you in
Intel®&rsquo;s new revolutionary product, Intel® Optane™ DC Persistent Memory?
I jest, of course, but it is my opinion that focusing on one category of
products, as characterized by the most prominent example from such category,
enables us to have a multidimensional discussion that captures more aspects
of a given problem.</p><p>And this is how we finally get to the number in the title of this post. One of
the more important characteristics of Intel&rsquo;s new Persistent Memory devices is
its average access latency. 300 nanoseconds.</p><h2 id=persistent-memory-programming-model>Persistent Memory Programming Model</h2><p>But that number alone doesn&rsquo;t mean much until we put it in context.</p><p><img src=/images/posts/300n_pyramid.png alt=map_insert></p><p>So, is 300 nanoseconds latency fast? For storage it definitely is, literally
orders of magnitude faster than any other technology. But for memory? Not really.
It&rsquo;s definitely fast enough to be considered memory, but it&rsquo;s also not fast
enough to be treated just like normal DRAM as far as data structure design is
concerned. Especially when we consider the broader aspects of the Persistent Memory Programming Model.</p><p><img src=/images/posts/300n_pmodel.png alt=map_insert></p><p>With persistent memory, just like with light, &ldquo;we have two contradictory pictures of reality&rdquo;.
It cannot be simply described as memory or storage, because neither of those
terms fully explains this new tier.</p><p>Just like with storage, it can be accessed through normal <strong>File I/O</strong> operations
such as <code>read()</code> or <code>write()</code>, and just like with memory, it can be accessed directly
at the byte level through <strong>Memory Mapped I/O</strong>, without an intervening page-cache layer.</p><p>And, just like with storage, the application needs to somehow synchronize
what it wrote to PMEM with the media, just like you&rsquo;d issue <code>fsync()</code> or
<code>msync()</code> to make sure that your I/O made it all the way to storage device.
In fact, those two calls do exactly that also for persistent memory - but there&rsquo;s
a better way.</p><p><img src=/images/posts/300n_pdomain.png alt=map_insert></p><p>Let&rsquo;s rewind a little first. I previously told you that persistent memory is
non-volatile and you can write to it directly. So why exactly do we need to
bother with synchronizing the I/O? Well, for the same reason we do it for regular
storage devices. There are various caches and buffers along the way of a store
from the application to the DIMM. Most importantly, there&rsquo;s the CPU cache.</p><p>We consider a store to be persistent when it reaches the persistent domain of
the platform. All stores that reside in the components that are within the
persistent domain are ensured to reach the DIMM, even in case of failures,
barring some catastrophic hardware problems.</p><p>To cut a long story short, in the common case this means that applications need to
push stores out of the CPU cache before it can be considered persistent.
You can do that with an <code>msync()</code> and the kernel will do the right thing,
but you also directly flush the CPU cache using user-space instructions, which
is beneficial for two reasons: a) there&rsquo;s no expensive syscall, and b) data
can be flushed with cacheline granularity, not a page granularity.</p><p>Oh, and cachelines are 64 bytes on x86-64, meaning that stores smaller than that
incur some write amplification when writing to the DIMM.</p><p>To sum up, persistent memory really is non-volatile, but stores need to be
flushed out of the CPU cache, ideally using user-space instructions on individual
cachelines.</p><p>But&mldr; (it seems like there&rsquo;s always a but) cache flushing instructions evict
the lines from the cache. Which means that reading something immediately after
writing it causes a cache miss - requiring the CPU to fetch that data from the DIMM.
And that&rsquo;s not all. Even writing something again within the same cacheline
after a flush will usually cause a cache miss, doubling the cost of a store.</p><h2 id=power-fail-atomicity>Power-fail atomicity</h2><p>All of that really doesn&rsquo;t matter until you want to create some data structure
that is actually persistent. And by persistent I mean a data structure whose
lifetime is longer than that of the process which created it.
However, that definition would also include data structures that are serialized
when the process quits, a well-known approach which is out of scope of
this post&mldr; because it&rsquo;s boring.
So, let&rsquo;s narrow down our focus to data structures that outlive processes and
are always consistent even in presence of failures. We usually say that such
data structures are failure atomic.</p><p>That sounds eerily similar to concurrent (atomic) data structures, doesn&rsquo;t it?
Just replace &ldquo;process&rdquo; with &ldquo;thread&rdquo; and &ldquo;failure&rdquo; with &ldquo;preemption&rdquo;.
This observation lies at the foundation of many ideas around persistent memory
in academia and industry alike. To come up with efficient algorithms, we,
the PMDK team, have been heavily taking advantage of the vast amount of work
that&rsquo;s been done for concurrent programming.</p><pre tabindex=0><code>	foo-&gt;bar = 10;

	...

	fetch_and_add(&amp;foo-&gt;bar, 5);
	/* visible = 15, persistent on DIMM = ? (10 or 15) */

	persist(&amp;foo-&gt;bar);
	/* visible = 15, persistent on DIMM = 15 */
</code></pre><p>One problem with straight out using concurrent data structures for failure
atomicity is the difference between visibility and persistence.
Concurrent data structure have to guarantee that all threads of execution always
see a consistent state. Persistent ones however also have to ensure that data is
present in the persistent domain before other processes or threads are allowed to
make any decisions based on the structure&rsquo;s state. Doing this the right way is
critical for performance.</p><h2 id=a-persistent-doubly-linked-list>A persistent doubly-linked list</h2><p>To better understand what I mean, let&rsquo;s look at an example.</p><p><img src=/images/posts/300n_linkedlist.png alt=map_insert></p><p>Each time an element is inserted into a linked list, there&rsquo;s a need to:</p><ol><li>Allocate a new object.</li><li>Fill it with data, including pointers to the next and previous entry.</li><li>Update the <code>next</code> pointer of the left entry</li><li>Update the <code>previous</code> pointer of the right entry.</li></ol><p>To do this in a concurrent way we could simply surround these operations
with some kind of a lock that would prevent other threads from accessing the list
while there&rsquo;s an ongoing insert. For the adventurous, writing a lock-free algorithm,
that could maybe scale better, is also an option.</p><p>Easy-ish. (Yes, I know&mldr; just give me this one.)</p><p>Making it failure atomic however, requires us to answer a couple of fundamental
questions. What does it even mean to allocate memory? The heap itself needs to
be persistent. And we have to make sure that the allocated object isn&rsquo;t leaked
when something interrupts the program. The heap is persistent after all.
Next, how will we make changes to multiple disjoint memory locations in a way
that is fail-safe atomic? It&rsquo;s not as simple as just preventing other processes
from viewing our data structure while we modify it. The execution
environment of our application can be brutally killed at any moment, forcing the
next process that attaches to the same persistent memory region to somehow deal
with the interrupted operation.
And finally, we have to ask ourselves if this is really what we want to do? Is
making a persistent doubly-linked list the goal? From my experience,
creating a data structure or an algorithm is just a means to an end. Once we
change our assumptions about memory a little bit, it might make more sense
to reconsider our initial instinct of just using what we know.</p><p>With libpmemobj, in retrospect, we&rsquo;ve incorrectly answered the first two
of those questions, and failed to even ask the third.</p><p>And with this, I&rsquo;ll leave you thinking until the holiday season is over :)</p><h2 id=end-of-part-1-of-2>End of part 1 (of 2)</h2><p>In this post, we&rsquo;ve learned about what persistent memory is and how it can be used.
We&rsquo;ve also discussed what it means for a data structure to be persistent, and how
that might affect performance.</p><p>In the next part, we are going to be diving deeper into my answers to the
three questions I&rsquo;ve posed, and how we&rsquo;ve improved our libraries based on
self reflections that we&rsquo;ve had after we reconsidered our initial assumptions
about persistent memory.</p><p>I wish you wonderful holidays and a happy New Year.</p><p><a href=/blog/2020/03/300-nanoseconds-2-of-2/>Link to part 2.</a></p><div class=clear></div><div class="si-share border-0 d-flex justify-content-between align-items-center"><span>Share this Post:</span><div id=share-buttons><div class="social-icon si-borderless si-facebook" title="Share this on Facebook" onclick='window.open("http://www.facebook.com/share.php?u=https://pmem.io/blog/2019/12/300-nanoseconds-1-of-2/")'><i class=icon-facebook></i>
<i class=icon-facebook></i></div><div class="social-icon si-borderless si-twitter" title="Share this on Twitter" onclick='window.open("http://twitter.com/intent/tweet?text=300 nanoseconds (1 of 2)&url=https://pmem.io/blog/2019/12/300-nanoseconds-1-of-2/")'><i class=icon-twitter></i>
<i class=icon-twitter></i></div><div class="social-icon si-borderless si-linkedin" title="Share this on Linkedin" onclick='window.open("https://www.linkedin.com/shareArticle?mini=true&url=https://pmem.io/blog/2019/12/300-nanoseconds-1-of-2/&title=&summary=&source=")'><i class=icon-linkedin></i>
<i class=icon-linkedin></i></div><div class="social-icon si-borderless si-pinterest" title="Share this on Pinterest" onclick='window.open("https://pinterest.com/pin/create/button/?url=&media=&description=")'><i class=icon-pinterest></i>
<i class=icon-pinterest></i></div><div class="social-icon si-borderless si-email3" title="Share this through Email" onclick='window.open("mailto:?&body=https://pmem.io/blog/2019/12/300-nanoseconds-1-of-2/")'><i class=icon-email3></i>
<i class=icon-email3></i></div></div></div></div></div><div class="row justify-content-between col-mb-30 post-navigation"><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2020/01/memkind-support-for-kmem-dax-option/?ref=footer">&lArr; Memkind support for KMEM DAX...</a></div><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2019/10/vmem-is-split-out-of-pmdk/?ref=footer">Vmem is split out of PMDK &rArr;</a></div></div><div class=line></div><h4>Related Posts:</h4><div class="related-posts row posts-md col-mb-30"></div></div></div><div class="sidebar col-lg-3"><div class=sidebar-widgets-wrap><div class="widget clearfix"><h4>Tag Cloud</h4><div class=tagcloud><a href=/tags/pmem class=block role=button>pmem</a>
<a href=/tags/persistent-memory class=block role=button>persistent-memory</a>
<a href=/tags/ndctl class=block role=button>ndctl</a>
<a href=/tags/pmdk class=block role=button>pmdk</a>
<a href=/tags/cxl class=block role=button>cxl</a>
<a href=/tags/daxctl class=block role=button>daxctl</a>
<a href=/tags/memkind class=block role=button>memkind</a>
<a href=/tags/async class=block role=button>async</a>
<a href=/tags/asynchronous class=block role=button>asynchronous</a>
<a href=/tags/concurrency class=block role=button>concurrency</a>
<a href=/tags/configure class=block role=button>configure</a>
<a href=/tags/dax class=block role=button>dax</a>
<a href=/tags/install class=block role=button>install</a>
<a href=/tags/intro class=block role=button>intro</a>
<a href=/tags/miniasync class=block role=button>miniasync</a>
<a href=/tags/setup class=block role=button>setup</a>
<a href=/tags/dml class=block role=button>dml</a>
<a href=/tags/dsa class=block role=button>dsa</a>
<a href=/tags/faq class=block role=button>faq</a>
<a href=/tags/imdb class=block role=button>imdb</a>
<a href=/tags/memory class=block role=button>memory</a>
<a href=/tags/pmem-use-case class=block role=button>pmem-use-case</a>
<a href=/tags/pmem2 class=block role=button>pmem2</a>
<a href=/tags/sanitize class=block role=button>sanitize</a>
<a href=/tags/secure-erase class=block role=button>secure-erase</a>
<a href=/tags/sql class=block role=button>sql</a>
<a href=/tags/tiering class=block role=button>tiering</a>
<a href=/tags/2019 class=block role=button>2019</a>
<a href=/tags/blogs class=block role=button>blogs</a>
<a href=/tags/crash class=block role=button>crash</a></div></div></div></div></div></div></div></section><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2023 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>