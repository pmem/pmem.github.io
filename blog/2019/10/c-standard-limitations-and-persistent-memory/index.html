<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="C++ standard limitations and Persistent Memory"><meta property="og:description" content="Introduction C++ language restrictions and the persistent memory programming paradigm imply serious restrictions on objects which may be stored on persistent medium. A user can access persistent memory with memory mapped files to take advantage of its byte addressability thanks to libpmemobj and Storage Networking Industry Association non-volatile memory programming model. No serialization takes place here, thus applications must be able to read and modify directly from the medium even after application was closed and reopened or after the event of power loss."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/blog/2019/10/c-standard-limitations-and-persistent-memory/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-10-04T19:55:17-07:00"><meta property="article:modified_time" content="2019-10-04T19:55:17-07:00"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>C++ standard limitations and Persistent Memory</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=content><div class="content-wrap dark-mode"><div class="container clearfix"><div class="row gutter-40 col-mb-80"><div class="postcontent col-lg-9 order-lg-last"><div class="single-post mb-0"><div class="entry clearfix"><div class=entry-title><h2>C++ standard limitations and Persistent Memory</h2></div><div class=entry-meta><ul><li><i class=icon-calendar3></i> 04 Oct, 2019</li><li><i class=icon-user></i> Szyrom</li><li><i class=icon-folder-open></i>
Limitations</li></ul></div><div class="entry-content mt-0"><h3 id=introduction>Introduction</h3><p>C++ language restrictions and the persistent memory programming paradigm imply
serious restrictions on objects which may be stored on persistent medium. A user can access
persistent memory with memory mapped files to take advantage of its byte addressability thanks
to libpmemobj and Storage Networking Industry Association non-volatile
memory programming model. No serialization takes place here, thus applications must be able
to read and modify directly from the medium even after application was closed and reopened or
after the event of power loss.</p><p>What does the above mean from the C++ and libpmemobj’s perspective? There are four
major problems which will be described in this blogpost:</p><ol><li><strong>Object lifetime</strong></li><li><strong>Snapshotting objects in transactions</strong></li><li><strong>Fixed on-media layout of stored objects</strong></li><li><strong>Pointers as object members</strong></li></ol><h3 id=object-lifetime>Object lifetime</h3><p>The lifetime of an object is described in <em>[basic.life]</em> section in the C++ standard:</p><blockquote><p>The lifetime of an object or reference is a runtime property of the object or reference. A variable is said to have vacuous initialization if it is default-initialized and, if it is of class type or a (possibly multi-dimensional) array thereof, that class type has a trivial default constructor. The lifetime of an object of type T begins when:</p><p>(1.1) storage with the proper alignment and size for type T is obtained, and</p><p>(1.2) its initialization (if any) is complete (including vacuous initialization) ([dcl.init]), except that if the object is a union member or subobject thereof, its lifetime only begins if that union member is the initialized member in the union ([dcl.init.aggr], [class.base.init]), or as described in [class.union].</p><p>The lifetime of an object o of type T ends when:</p><p>(1.3) if T is a non-class type, the object is destroyed, or</p><p>(1.4) if T is a class type, the destructor call starts, or</p><p>(1.5) the storage which the object occupies is released, or is reused by an object that is not nested within o ([intro.object]).</p></blockquote><p>The standard states that properties ascribed to objects apply for a given
object only during its lifetime. In this context, persistent memory programming problem is similar
to transmitting data over a network where the C++ application is given an array of bytes but
might be able to recognize the type of object sent. However, the object was not constructed in
this application so using it would result in undefined behavior. This problem is well known and is
being addressed by WG21 (The C++ Standards Committee Working Group).</p><p>Currently there is no possible way to overcome object’s lifetime obstacle and stop relying on
undefined behavior from C++ standard’s point of view. libpmemobj++ bindings are tested and
validated with various C++11 complaint compilers and use case scenarios and the only
recommendation for libpmemobj C++ users is that they must keep in mind this limitation when
designing their persistent memory application.</p><h3 id=trivial-types>Trivial types</h3><p>Transactions are the heart of libpmemobj. That is why libpmemobj++ was implemented
with utmost care while designing their C++ versions, so that they are as easy to use as possible.
It means that the user doesn’t have to know about implementation details and doesn’t have
to care about snapshotting modified data in order to make undo-log based transaction works. A
special semi-transparent template property class <code>pmem::obj::p&lt;></code> has been implemented to automatically add
variable modifications to the transaction undo log.</p><p>But what does it mean to snapshot the data? The answer is very simple, but the
consequences for C++ are serious. libpmemobj implements snapshotting by copying data of
given length from given address to another address with <code>memcpy()</code>. If transaction aborts
or the event of power loss occurs, the data is being copied again from undo log on pool reopen.
Consider a definition of the following C++ object and think about the consequences
of memcpying it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>nonTriviallyCopyable</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    nonTriviallyCopyable (<span style=color:#66d9ef>const</span> nonTriviallyCopyable<span style=color:#f92672>&amp;</span> from)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* perform non-trivial copying routine */</span>
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span>(<span style=color:#66d9ef>int</span>(<span style=color:#f92672>*</span>from.i));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Deep and shallow copying is the simplest example. The gist of the problem is that by
copying the data manually, we may break the inherent behavior of the object which may rely on
the copy constructor. Any shared or unique pointer would be another great example - by simple
copying it with <code>memcpy()</code> we break the <em>deal</em> we made with that class when we used it and it
may lead to leaks or crashes.</p><p>There are many more sophisticated details the application must deal with when it
manually copies the contents of an object. C++11 standard provides in
header <code>&lt;type_traits></code> type trait <code>std::is_trivially_copyable</code> which ensures if a given
type satisfies the requirements of <code>TriviallyCopyable</code>. Referring to C++ standard, an object
satisfies requirements of <code>TriviallyCopyable</code> when:</p><blockquote><p>A trivially copyable class is a class that:</p><p>— has no non-trivial copy constructors (12.8),</p><p>— has no non-trivial move constructors (12.8),</p><p>— has no non-trivial copy assignment operators (13.5.3, 12.8),</p><p>— has no non-trivial move assignment operators (13.5.3, 12.8), and</p><p>— has a trivial destructor (12.4).</p><p>A trivial class is a class that has a trivial default constructor (12.1) and is trivially copyable. [ Note: In particular, a trivially copyable or trivial class does not have virtual functions or virtual base classes.—end note ]</p></blockquote><p>And this is how the C++ standard defines non-trivial methods:</p><blockquote><p>A copy/move constructor for class X is trivial if it is not user-provided and if</p><p>— class X has no virtual functions (10.3) and no virtual base classes (10.1), and</p><p>— the constructor selected to copy/move each direct base class subobject is trivial, and</p><p>— for each non-static data member of X that is of class type (or array thereof), the constructor selected to copy/move that member is trivial;</p><p>otherwise the copy/move constructor is non-trivial.</p></blockquote><p>This means that a copy or move constructor is trivial if it is not user-provided, the class has
nothing virtual in it and this property holds recursively for all the members of the class and for
the base class. As you can see, C++ standard and libpmemobj transactions implementation
limits the possible objects type to store on persistent memory to satisfy requirements of trivial
types but the layout of our objects must be taken into account.</p><h3 id=object-layout>Object layout</h3><p>Object representation (layout) might differ between compilers/compiler flags/ABI. The
compiler may do some layout-related optimizations and is free to shuffle order of members with
same specifier type (public/protected/public). Another problem related to unknown object layout
is connected to polymorphic types. Currently there is no reliable and portable way to
implement vtable rebuilding after reopening the pool, polymorphic objects cannot be supported
with persistent memory.</p><p>If we want to store objects on persistent memory (memory mapped files – to be precise
and to follow SNIA NVM programming model), we must ensure that following casting will be
always valid:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>someType A <span style=color:#f92672>=</span> _reinterpret_cast<span style=color:#f92672>&lt;</span>someType_<span style=color:#f92672>&gt;</span>(mmap(...));
</span></span></code></pre></div><p>In other words, the bit representation of stored object type must be always the same
and our application should be able to retrieve stored object from memory mapped file without
serialization.</p><p>It is possible to ensure that a specific type satisfies above requirements. C++11 provides
another type trait <code>std::is_standard_layout</code>. The standard mentions that it is useful for
communicating with other languages (for creating language bindings to native C++ libraries
e.g.), and that&rsquo;s why a standard-layout class has the same memory layout of the equivalent C
struct or union. A general rule is saying that standard-layout classes must have all non-static
data members with the same access control (we mentioned at the beginning of this blogpost,
that C++ compliant compiler is free to shuffle access ranges of the same class definition). When
using inheritance, only one class in the whole inheritance tree can have non-static data
members, and the first non-static data member cannot be of a base class type (this could break
aliasing rules), otherwise, it&rsquo;s not a standard-layout class.</p><p>C++11 defines <code>std::is_standard_layout</code> as follows:</p><blockquote><p>A standard-layout class is a class that:</p><p>— has no non-static data members of type non-standard-layout class (or array of such types) or reference,</p><p>— has no virtual functions (10.3) and no virtual base classes (10.1),</p><p>— has the same access control (Clause 11) for all non-static data members,</p><p>— has no non-standard-layout base classes,</p><p>— either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and</p><p>— has no base classes of the same type as the first non-static data member.</p><p>A standard-layout struct is a standard-layout class defined with the class-key struct or the class-key class.</p><p>A standard-layout union is a standard-layout class defined with the class-key union.</p><p>[ Note: Standard-layout classes are useful for communicating with code written in other programming languages. Their layout is specified in 9.2.—end note ]</p></blockquote><p>Having discussed object layout, we may dive into another interesting problem with types
possible to store on persistent memory: pointers.</p><h3 id=pointers>Pointers</h3><p>In previous sections we were quoting standard multiple times. We were describing
limits of types which were safe to snapshot, copy around and which we can binary-cast without
thinking of fixed-layout. But what about pointers? How does one deal with them in our objects as
one comes to grips with Persistent Memory Programming Model? Let’s consider the following
simple code snippet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> vptr1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> vptr2;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> a1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>/* variable on stack */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>a2 <span style=color:#f92672>=</span> mmap(...); <span style=color:#75715e>/* pointer to persistent variable */</span>
</span></span><span style=display:flex><span>a2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>pmem<span style=color:#f92672>::</span>obj<span style=color:#f92672>::</span>transaction<span style=color:#f92672>::</span>run(pop, [<span style=color:#f92672>&amp;</span>](){
</span></span><span style=display:flex><span>    root<span style=color:#f92672>-&gt;</span>ptrA <span style=color:#f92672>=</span> pmem<span style=color:#f92672>::</span>obj<span style=color:#f92672>::</span>make_persistent<span style=color:#f92672>&lt;</span>A<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    root<span style=color:#f92672>-&gt;</span>ptrA<span style=color:#f92672>-&gt;</span>vptr1 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>a1;
</span></span><span style=display:flex><span>    root<span style=color:#f92672>-&gt;</span>ptrA<span style=color:#f92672>-&gt;</span>vptr2 <span style=color:#f92672>=</span> a2;
</span></span><span style=display:flex><span>};);
</span></span></code></pre></div><p>We are using libpmemobj++ transactional API. Class <code>A</code> does have two volatile pointers.
Our application is assigning (transactionally) two virtual addresses – one to integer residing on
stack and the second one to integer residing on persistent medium. What will happen if an
application crashes or exits after execution of the transaction and if we run application again?
Since the variable <code>a1</code> was residing on stack, the old value vanished. But what with value
assigned to <code>a2</code>? Even if it resides on persistent medium, the volatile pointer is no longer valid
(we are not guaranteed that if we call <code>mmap()</code> again, it will be mapped to the same virtual
address space region). The same problem applies to variable a1 and virtual address space
pointer to it, but we wanted to underline problem with volatility of value on DRAM.
As shown in the example above, it is very important to realize that storing volatile
memory pointers in persistent memory is almost always a design error.</p><p>Using <code>pmem::obj::persistent_ptr&lt;></code> class template is safe, and it provides only way to
access specific memory area after application crash. However, <code>pmem::obj::persistent_ptr&lt;></code> type doesn’t
satisfy <code>TriviallyCopyable</code> requirements (because of explicitly-defined constructors). As a
result, the object with a <code>pmem::obj::persistent_ptr&lt;></code> as a member, won’t
pass <code>std::is_trivially_copyable</code> check. Every persistent memory programmer should
always check whether <code>pmem::obj::persistent_ptr&lt;></code> could be copied in that specific
case and if that wouldn’t cause errors and (persistent) memory leaks. One should realize
that <code>std::is_trivially_copyable</code> is the syntax check only and it doesn’t tests semantics.
Technically speaking, using <code>pmem::obj::persistent_ptr&lt;></code> in this context leads to
undefined behavior. There is no golden mean and since C++ standard does not fully support
persistent memory programming, we should make sure that copying <code>pmem::obj::persistent_ptr&lt;></code> is safe to use in our case.
Now we are ready to summarize all standard and programming model related
restrictions and move forward to the next subchapter.</p><h3 id=summary>Summary</h3><p>C++11 provides a couple of features for persistent memory programmer. The
most accurate type traits are:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>std</span><span style=color:#f92672>::</span>is_pod;
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>std</span><span style=color:#f92672>::</span>is_trivial;
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>std</span><span style=color:#f92672>::</span>is_trivially_copyable;
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>std</span><span style=color:#f92672>::</span>is_standard_layout;
</span></span></code></pre></div><p>They are correlated with each other. The most general and restrictive is definition of POD type
(however, <code>std::is_pod</code> will be deprecated in C++20):</p><p><img src=/images/posts/cpptraitsdiagram.png alt=diagram></p><p>As we already mentioned, persistent memory-resident class must satisfy requirements of:</p><ul><li><code>std::is_trivially_copyable</code></li><li><code>std::is_standard_layout</code></li></ul><p>Persistent memory programmer is free to use more restrictive type traits. If we want to use
persistent pointers however, we cannot rely on type-traits and must be aware of all problems
related to copying objects with <code>memcpy()</code> and layout representation of objects. For Persistent
Memory Programming concept, formal description or standardization of the aforementioned
concepts and features should take place. We must be aware and deal with object
lifetime related undefined behavior.</p><div class=clear></div><div class="si-share border-0 d-flex justify-content-between align-items-center"><span>Share this Post:</span><div id=share-buttons><div class="social-icon si-borderless si-facebook" title="Share this on Facebook" onclick='window.open("http://www.facebook.com/share.php?u=https://pmem.io/blog/2019/10/c-standard-limitations-and-persistent-memory/")'><i class=icon-facebook></i>
<i class=icon-facebook></i></div><div class="social-icon si-borderless si-twitter" title="Share this on Twitter" onclick='window.open("http://twitter.com/intent/tweet?text=C\u002b\u002b standard limitations and Persistent Memory&url=https://pmem.io/blog/2019/10/c-standard-limitations-and-persistent-memory/")'><i class=icon-twitter></i>
<i class=icon-twitter></i></div><div class="social-icon si-borderless si-linkedin" title="Share this on Linkedin" onclick='window.open("https://www.linkedin.com/shareArticle?mini=true&url=https://pmem.io/blog/2019/10/c-standard-limitations-and-persistent-memory/&title=&summary=&source=")'><i class=icon-linkedin></i>
<i class=icon-linkedin></i></div><div class="social-icon si-borderless si-pinterest" title="Share this on Pinterest" onclick='window.open("https://pinterest.com/pin/create/button/?url=&media=&description=")'><i class=icon-pinterest></i>
<i class=icon-pinterest></i></div><div class="social-icon si-borderless si-email3" title="Share this through Email" onclick='window.open("mailto:?&body=https://pmem.io/blog/2019/10/c-standard-limitations-and-persistent-memory/")'><i class=icon-email3></i>
<i class=icon-email3></i></div></div></div></div></div><div class="row justify-content-between col-mb-30 post-navigation"><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2019/10/new-release-of-pmdk/?ref=footer">&lArr; New release of PMDK</a></div><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2019/06/multi-level-vmemcache/?ref=footer">Multi-level vmemcache &rArr;</a></div></div><div class=line></div><h4>Related Posts:</h4><div class="related-posts row posts-md col-mb-30"></div></div></div><div class="sidebar col-lg-3"><div class=sidebar-widgets-wrap><div class="widget clearfix"><h4>Tag Cloud</h4><div class=tagcloud><a href=/tags/pmem class=block role=button>pmem</a>
<a href=/tags/persistent-memory class=block role=button>persistent-memory</a>
<a href=/tags/ndctl class=block role=button>ndctl</a>
<a href=/tags/pmdk class=block role=button>pmdk</a>
<a href=/tags/cxl class=block role=button>cxl</a>
<a href=/tags/daxctl class=block role=button>daxctl</a>
<a href=/tags/memkind class=block role=button>memkind</a>
<a href=/tags/async class=block role=button>async</a>
<a href=/tags/asynchronous class=block role=button>asynchronous</a>
<a href=/tags/concurrency class=block role=button>concurrency</a>
<a href=/tags/configure class=block role=button>configure</a>
<a href=/tags/dax class=block role=button>dax</a>
<a href=/tags/install class=block role=button>install</a>
<a href=/tags/intro class=block role=button>intro</a>
<a href=/tags/miniasync class=block role=button>miniasync</a>
<a href=/tags/setup class=block role=button>setup</a>
<a href=/tags/dml class=block role=button>dml</a>
<a href=/tags/dsa class=block role=button>dsa</a>
<a href=/tags/faq class=block role=button>faq</a>
<a href=/tags/imdb class=block role=button>imdb</a>
<a href=/tags/memory class=block role=button>memory</a>
<a href=/tags/pmem-use-case class=block role=button>pmem-use-case</a>
<a href=/tags/pmem2 class=block role=button>pmem2</a>
<a href=/tags/sanitize class=block role=button>sanitize</a>
<a href=/tags/secure-erase class=block role=button>secure-erase</a>
<a href=/tags/sql class=block role=button>sql</a>
<a href=/tags/tiering class=block role=button>tiering</a>
<a href=/tags/2019 class=block role=button>2019</a>
<a href=/tags/blogs class=block role=button>blogs</a>
<a href=/tags/crash class=block role=button>crash</a></div></div></div></div></div></div></div></section><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2023 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>