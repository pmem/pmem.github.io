<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="Transactional key-value store using libpmemobj - DIY"><meta property="og:description" content="Our library often gets compared to NoSQL databases because it stores things on storage in unstructured manner. Which is true, but, when you think about it, the pmemobj library is not technically a database, but can be used to implement one - like the MySQL storage engine example. In this post I&rsquo;ll describe an example implementation of transactional kv-store, that has two different backends, which I&rsquo;ll then compare. To make things more interesting, it&rsquo;s not going to be your typical kv-store, since the data structure behind it won&rsquo;t be a hashmap."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/blog/2015/07/transactional-key-value-store-using-libpmemobj-diy/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2015-07-31T19:55:17-07:00"><meta property="article:modified_time" content="2015-07-31T19:55:17-07:00"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>Transactional key-value store using libpmemobj - DIY</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=content><div class="content-wrap dark-mode"><div class="container clearfix"><div class="row gutter-40 col-mb-80"><div class="postcontent col-lg-9 order-lg-last"><div class="single-post mb-0"><div class="entry clearfix"><div class=entry-title><h2>Transactional key-value store using libpmemobj - DIY</h2></div><div class=entry-meta><ul><li><i class=icon-calendar3></i> 31 Jul, 2015</li><li><i class=icon-user></i> Pbalcer</li><li><i class=icon-folder-open></i>
Kvstore</li></ul></div><div class="entry-content mt-0"><p>Our library often gets compared to NoSQL databases because it stores things on
storage in unstructured manner. Which is true, but, when you think about it,
the pmemobj library is not technically a database, but can be used to implement
one - like the MySQL storage engine example. In this post I&rsquo;ll describe an
example implementation of transactional kv-store, that has two different
backends, which I&rsquo;ll then compare. To make things more interesting, it&rsquo;s not
going to be your typical kv-store, since the data structure behind it won&rsquo;t
be a hashmap. Instead, I&rsquo;ve selected two different tree algorithms, namely
b-tree and crit-bit tree.</p><h3 id=the-api-design--features>The API design & features</h3><p>For simplicity sake, the types of our key and value will be <code>uint64_t</code> and
<code>PMEMoid</code> respectively. All of our functions will work inside and outside a
pmemobj transaction. The user will be able to start transaction, do a bulk
insert and then commit that transaction. The user will be also able to insert
various types into the same collection and then leverage the built-in type
information of <code>PMEMoid</code> using <code>OID_INSTANCEOF</code> macro. Also, since our entire
library is implicitly persistent, the store will never lose data. And all of
this comes at almost no implementation cost, since we will rely heavily on the
libpmemobj.</p><p>The header file is available
<a href=https://github.com/pmem/pmdk/blob/master/src/examples/libpmemobj/map/map.h>here</a>.
It&rsquo;s pretty simple, but extending it should be fairly easy.</p><h3 id=implementation>Implementation</h3><p>As I already mentioned, there will be 2 backends with different algorithms.
Those data structures are general knowledge and I won&rsquo;t describe them here. The
implementation itself doesn&rsquo;t not differ too much from what a volatile one would
look like. I suspect that if one removed all the pmemobj specific stuff both
trees would probably work fine as a volatile structures.</p><h4 id=crit-bit-treehttpscryptocritbithtml><a href=https://cr.yp.to/critbit.html>Crit-bit Tree</a></h4><p>This is a very simple to implement data structure whose insert operation, once
the destination node of the new entry is found, does exactly <strong>one</strong> store to
modify the tree. There are no rotations and fancy complicated algorithms going
on here. Why is this important? There&rsquo;s potentially less data in the undo log of
the transaction, one could even write non-transactional version of this data
structure. The remove operation is similarly straightforward. However, it&rsquo;s
important to note that internal nodes do not hold values and there can be a lot
of internal nodes when dealing with non-sparse collection of keys.</p><p>The complete implementation can be found
<a href=https://github.com/pmem/pmdk/tree/master/src/examples/libpmemobj/tree_map/ctree_map.c>here</a>.</p><h4 id=b-treehttpsenwikipediaorgwikib-tree><a href=https://en.wikipedia.org/wiki/B-tree>B-Tree</a></h4><p>A far more popular structure, that, in contrast to the crit-bit, does store
values on internal nodes, and what&rsquo;s more - it stores N of them. Meaning that
it will take far less allocations to store the same amount of entries. This
comes at a cost of considerably more complicated algorithm and far heavier
usage of transactions. And this is exactly why I&rsquo;ve chosen B-Trees.</p><p>The implementation is available
<a href=https://github.com/pmem/pmdk/tree/master/src/examples/libpmemobj/tree_map/btree_map.c>here</a>.</p><h3 id=the-end-result>The end result</h3><p>What I&rsquo;ve ended up with is a sorted map collection interface with two different
implementations. The API supplements the libpmemobj and integrates with it
seamlessly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>store_item</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* data */</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>my_root</span> {
</span></span><span style=display:flex><span>    TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>tree_map</span>) map;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* create a new collection */</span>
</span></span><span style=display:flex><span>TX_BEGIN(pop) {
</span></span><span style=display:flex><span>    tree_map_new(pop, <span style=color:#f92672>&amp;</span>D_RW(root)<span style=color:#f92672>-&gt;</span>map);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * We don&#39;t want an empty collection, so let&#39;s insert
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * a few new entries in the same transaction.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>store_item</span>) n;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> TX_NEW(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>store_item</span>);
</span></span><span style=display:flex><span>    tree_map_insert(pop, D_RO(root)<span style=color:#f92672>-&gt;</span>map, <span style=color:#ae81ff>5</span>, n.oid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> TX_NEW(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>store_item</span>);
</span></span><span style=display:flex><span>    tree_map_insert(pop, D_RO(root)<span style=color:#f92672>-&gt;</span>map, <span style=color:#ae81ff>10</span>, n.oid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} TX_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* the backend is a tree, and so the collection is sorted */</span>
</span></span><span style=display:flex><span>tree_map_foreach(D_RO(root)<span style=color:#f92672>-&gt;</span>map, <span style=color:#75715e>/* ... */</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* all functions can be used outside of a transaction as well */</span>
</span></span><span style=display:flex><span>PMEMoid oid <span style=color:#f92672>=</span> tree<span style=color:#f92672>*</span>map_remove(pop, D_RO(root)<span style=color:#f92672>-&gt;</span>map, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>/* the object type can be verified */</span>
</span></span><span style=display:flex><span>assert(OID_INSTANCEOF(oid, <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>store_item</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>tree_map_delete(pop, <span style=color:#f92672>&amp;</span>D_RW(root)<span style=color:#f92672>-&gt;</span>map);
</span></span></code></pre></div><p>So a fairly standard kv-store. There&rsquo;s a more complete example
<a href=https://github.com/pmem/pmdk/blob/master/src/examples/libpmemobj/map/data_store.c>here</a>.</p><h3 id=performance>Performance</h3><p>All tests were ran on a ramdisk with <a href=https://github.com/01org/prd>ext4 + DAX</a>
filesystem. The numbers are only good for comparison between the two data
structures. If you want more meaningful data run the benchmarks for yourself.
Not to mention my measurements weren&rsquo;t very scientific. The order of B-Tree I&rsquo;ve
selected is 8.</p><p>The first scenario is inserting 1 mln entries with random keys:</p><table><thead><tr><th style=text-align:left>Structure</th><th style=text-align:left>Outer TX</th><th style=text-align:left>Time</th></tr></thead><tbody><tr><td style=text-align:left>B-Tree</td><td style=text-align:left>Yes</td><td style=text-align:left>2.588s</td></tr><tr><td style=text-align:left>B-Tree</td><td style=text-align:left>No</td><td style=text-align:left>9.812s</td></tr><tr><td style=text-align:left>Crit-bit</td><td style=text-align:left>Yes</td><td style=text-align:left>17.707s</td></tr><tr><td style=text-align:left>Crit-bit</td><td style=text-align:left>No</td><td style=text-align:left>17.145s</td></tr></tbody></table><p>So, inserting elements into B-Tree takes significantly less time - this is
because it does far less allocations. But more interestingly, when inserting
all of the entries in a single transaction the performance is way better
for B-Tree. It does make sense, when you think about it for a while. The
benchmark program allocated an entire tree and all of its elements in a single
transaction. This means that there&rsquo;s no reason to keep the undo log for any
modifications - because an abort of such transaction means simply discarding
all of the allocated objects - we didn&rsquo;t modify any existing data. So why the
crit-bit didn&rsquo;t benefit as much? The crit-bit uses <code>pmemobj_tx_add_range_direct</code>
that cannot verify if the <code>PMEMoid</code> it operates on was allocated in the same
transaction, and thus always creates the (useless) undo log entries. This is one
of the API functions we want to optimize later on, so anomalies like these won&rsquo;t
happen. Another reason why the crit-bit performs worse than B-Tree is because
it creates many very tiny undo log entries (to change a single PMEMoid) which
wastes a lot of memory and time on allocating. This inspired an optimization
proposal to create an undo log cache which will be preallocated for each
transaction and will store undo log entries whose size doesn&rsquo;t exceed a yet to
be determined threshold, this should cut the number of allocations performed by
c-tree in half.</p><p>Next scenario is removal of 1 mln entries with random keys:</p><table><thead><tr><th style=text-align:left>Structure</th><th style=text-align:left>Outer TX</th><th style=text-align:left>Time</th></tr></thead><tbody><tr><td style=text-align:left>B-Tree</td><td style=text-align:left>Yes</td><td style=text-align:left>13.874s</td></tr><tr><td style=text-align:left>B-Tree</td><td style=text-align:left>No</td><td style=text-align:left>22.540s</td></tr><tr><td style=text-align:left>Crit-bit</td><td style=text-align:left>Yes</td><td style=text-align:left>27.629s</td></tr><tr><td style=text-align:left>Crit-bit</td><td style=text-align:left>No</td><td style=text-align:left>24.268s</td></tr></tbody></table><p>And again we see similar pattern emerging, for pretty much the same reasons.</p><p>I still believe crit-bit is capable of outperforming B-Tree, but that would
require a slightly less-readable implementation that does not allocate leaf
nodes but instead treats empty internal nodes as leafs, which should bring
quite substantial reduction in allocations. And also, we need to optimize the
<code>pmemobj_tx_add_range_direct</code> function to perform similarly to the
<code>pmemobj_tx_add_range</code>. I plan on revisiting this topic once we finish
optimizing the library functions, including the allocator.</p><h6 id=this-entry-was-edited-on-2017-12-11-to-reflect-the-name-change-from-nvml-to-pmdkblog201712announcing-the-persistent-memory-development-kit>[This entry was edited on 2017-12-11 to reflect the name change from <a href=/blog/2017/12/announcing-the-persistent-memory-development-kit>NVML to PMDK</a>.]</h6><div class=clear></div><div class="si-share border-0 d-flex justify-content-between align-items-center"><span>Share this Post:</span><div id=share-buttons><div class="social-icon si-borderless si-facebook" title="Share this on Facebook" onclick='window.open("http://www.facebook.com/share.php?u=https://pmem.io/blog/2015/07/transactional-key-value-store-using-libpmemobj-diy/")'><i class=icon-facebook></i>
<i class=icon-facebook></i></div><div class="social-icon si-borderless si-twitter" title="Share this on Twitter" onclick='window.open("http://twitter.com/intent/tweet?text=Transactional key-value store using libpmemobj - DIY&url=https://pmem.io/blog/2015/07/transactional-key-value-store-using-libpmemobj-diy/")'><i class=icon-twitter></i>
<i class=icon-twitter></i></div><div class="social-icon si-borderless si-linkedin" title="Share this on Linkedin" onclick='window.open("https://www.linkedin.com/shareArticle?mini=true&url=https://pmem.io/blog/2015/07/transactional-key-value-store-using-libpmemobj-diy/&title=&summary=&source=")'><i class=icon-linkedin></i>
<i class=icon-linkedin></i></div><div class="social-icon si-borderless si-pinterest" title="Share this on Pinterest" onclick='window.open("https://pinterest.com/pin/create/button/?url=&media=&description=")'><i class=icon-pinterest></i>
<i class=icon-pinterest></i></div><div class="social-icon si-borderless si-email3" title="Share this through Email" onclick='window.open("mailto:?&body=https://pmem.io/blog/2015/07/transactional-key-value-store-using-libpmemobj-diy/")'><i class=icon-email3></i>
<i class=icon-email3></i></div></div></div></div></div><div class="row justify-content-between col-mb-30 post-navigation"><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2015/09/kv-store-improved-measured/?ref=footer">&lArr; KV-store improved & measured</a></div><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2015/07/an-introduction-to-pmemcheck-part-2-transactions/?ref=footer">An introduction to pmemcheck... &rArr;</a></div></div><div class=line></div><h4>Related Posts:</h4><div class="related-posts row posts-md col-mb-30"></div></div></div><div class="sidebar col-lg-3"><div class=sidebar-widgets-wrap><div class="widget clearfix"><h4>Tag Cloud</h4><div class=tagcloud><a href=/tags/pmem class=block role=button>pmem</a>
<a href=/tags/persistent-memory class=block role=button>persistent-memory</a>
<a href=/tags/ndctl class=block role=button>ndctl</a>
<a href=/tags/pmdk class=block role=button>pmdk</a>
<a href=/tags/cxl class=block role=button>cxl</a>
<a href=/tags/daxctl class=block role=button>daxctl</a>
<a href=/tags/memkind class=block role=button>memkind</a>
<a href=/tags/async class=block role=button>async</a>
<a href=/tags/asynchronous class=block role=button>asynchronous</a>
<a href=/tags/concurrency class=block role=button>concurrency</a>
<a href=/tags/configure class=block role=button>configure</a>
<a href=/tags/dax class=block role=button>dax</a>
<a href=/tags/install class=block role=button>install</a>
<a href=/tags/intro class=block role=button>intro</a>
<a href=/tags/miniasync class=block role=button>miniasync</a>
<a href=/tags/setup class=block role=button>setup</a>
<a href=/tags/dml class=block role=button>dml</a>
<a href=/tags/dsa class=block role=button>dsa</a>
<a href=/tags/faq class=block role=button>faq</a>
<a href=/tags/imdb class=block role=button>imdb</a>
<a href=/tags/memory class=block role=button>memory</a>
<a href=/tags/pmem-use-case class=block role=button>pmem-use-case</a>
<a href=/tags/pmem2 class=block role=button>pmem2</a>
<a href=/tags/sanitize class=block role=button>sanitize</a>
<a href=/tags/secure-erase class=block role=button>secure-erase</a>
<a href=/tags/sql class=block role=button>sql</a>
<a href=/tags/tiering class=block role=button>tiering</a>
<a href=/tags/2019 class=block role=button>2019</a>
<a href=/tags/blogs class=block role=button>blogs</a>
<a href=/tags/crash class=block role=button>crash</a></div></div></div></div></div></div></div></section><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2023 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>