<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="An introduction to pmemcheck (part 1) - basics"><meta property="og:description" content="As you probably noticed from the previous posts, persistent memory programming isn&rsquo;t really that easy. There are a couple of things you have to consider - data consistency being the most important one. The contemporary x86_64 architecture supports at most 8-byte atomic stores. You probably know by now, that by atomic I mean non-torn and not thread-safe. This means that you can be confident that you will not get 4 out of the 8 bytes with the new value and the rest will not be updated."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/blog/2015/07/an-introduction-to-pmemcheck-part-1-basics/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2015-07-17T19:55:17-07:00"><meta property="article:modified_time" content="2015-07-17T19:55:17-07:00"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>An introduction to pmemcheck (part 1) - basics</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=content><div class="content-wrap dark-mode"><div class="container clearfix"><div class="row gutter-40 col-mb-80"><div class="postcontent col-lg-9 order-lg-last"><div class="single-post mb-0"><div class="entry clearfix"><div class=entry-title><h2>An introduction to pmemcheck (part 1) - basics</h2></div><div class=entry-meta><ul><li><i class=icon-calendar3></i> 17 Jul, 2015</li><li><i class=icon-user></i> Tomaszkapela</li><li><i class=icon-folder-open></i>
Pmemcheck</li></ul></div><div class="entry-content mt-0"><p>As you probably noticed from the previous posts, persistent memory programming isn&rsquo;t really that easy. There are a couple of things you have to consider - data consistency being the most important one. The contemporary x86_64 architecture supports at most 8-byte atomic stores. You probably know by now, that by atomic I mean non-torn and not thread-safe. This means that you can be confident that you will not get 4 out of the 8 bytes with the new value and the rest will not be updated. However, there aren&rsquo;t many real-life programs that think in 8 byte chunks of data. Therefore <a href=/pmdk/ title="Persistent Memory Development Kit">PMDK</a> resorts to <strong>non-trivial tricks</strong> to ensure larger portions of memory can be updated in a failsafe manner.</p><p>Since our libraries are quite complicated, we needed a way to check for possible issues with persistent memory usage. As the persistent memory programming concept is fairly new, there aren&rsquo;t any free, widely available tools, which could help us with this task. This is why we came up with the idea to write one ourselves. We ruled out static analysis, because keeping track of pointers to persistent memory would be really tedious (we don&rsquo;t have any language additions for them). This leaves us with dynamic, runtime analysis. After some pathfinding we decided to use Valgrind, mostly because of its popularity and familiarity within the C/C++ developer community. Another very important factor was that Valgrind enables us to recognize and instrument at instruction level. As such we plan to add automatic support for flushes and memory barriers (PCOMMIT included) - at least for the x86_64 architecture. This is in short how the <strong>pmemcheck</strong> side-project started.</p><p>We wanted the tool to be as flexible as possible, so that it could be used with the current and future implementations of different libraries using persistent memory. Because of this, the tool relies heavily on information from the instrumented application. The information is fed through a built-in Valgrind mechanism (<a href=https://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.clientreq title="Client Request Mechanism">CRM</a>) with a set of predefined macros. I won&rsquo;t go into details of the implementation as it is available on github and you can take a look at both the <a href=https://github.com/pmem/valgrind/blob/pmem-3.15/pmemcheck/docs/pmc-manual.xml title="Pmemcheck documentation">documentation</a> and the <a href=https://github.com/pmem/valgrind title=Valgrind-pmemcheck>code</a> (hopefully contribute or make feature requests). The idea is: we track all stores you make to persistent memory and inform you of possible memory violations. Let&rsquo;s dive into some simple examples, because that&rsquo;s usually the easier way to learn things.</p><h3 id=basic-usage>Basic usage</h3><p>Because our tool is still a prototype, it is only available on <a href=https://github.com/pmem/valgrind title=Valgrind-pmemcheck>github</a>. Once you get the tree, you have to manually build and install it. If you have any trouble installing, look at either the provided github page or the official <a href=https://valgrind.org/ title=Valgrind>Valgrind homepage</a> for more info. If you still experience trouble building and installing pmemcheck, either contact me @tomaszkapela or file an <a href=https://github.com/pmem/valgrind/issues title="pmemcheck issues">issue</a>. Once that is done, to run an application under pmemcheck type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ valgrind --tool<span style=color:#f92672>=</span>pmemcheck <span style=color:#f92672>[</span>valgrind options<span style=color:#f92672>]</span> &lt;your_app&gt; <span style=color:#f92672>[</span>your_app options<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>The most basic example you can imagine is acquiring a persistent memory region and writing to it. As pmemcheck doesn&rsquo;t really care how you acquire it or where it really is (frankly it doesn&rsquo;t even care if it really is persistent memory - as you will see in the example), you have to tell it explicitly which regions to track using the <code>VALGRIND_PMC_REGISTER_PMEM_MAPPING(addr, size)</code> macro. To sum up, in the most simplistic form this could look like:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;valgrind/pmemcheck.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ip;
</span></span><span style=display:flex><span>    VALGRIND_PMC_REGISTER_PMEM_MAPPING(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>    ip <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    VALGRIND_PMC_REMOVE_PMEM_MAPPING(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>}</span></span></code></pre></td></tr></table></div></div><p>This example has one major error. The store at <code>ip = 5;</code> isn&rsquo;t made persistent and pmemcheck will tell you about it. If the executed binary has debug symbols available, you will get a nice stacktrace for each issue. The output looks like the following:</p><pre tabindex=0><code>    Number of stores not made persistent: 1
    Stores not made persistent properly:
    [0]    at 0x400794: main (example.c:7)
    	   Address: 0xfff000124	size: 4	state: DIRTY
    Total memory not made persistent: 4
</code></pre><p>As you can see, the output is fairly straightforward. The tool tells you that in function <code>main</code> in file <code>example.c</code> at line 7, you made a store of size 4 (bytes, obviously) and at program exit the state of the store is <code>DIRTY</code>. The last line is the total number of bytes that were not made persistent properly. Here I should probably explain what it means to make something persistent. Taken from pmemcheck&rsquo;s documentation: <em>To make the data persistent, preferably in a failsafe manner, you have to do a STORE->FLUSH->SFENCE->PCOMMIT->SFENCE sequence</em>. Now that we know what we did wrong, let&rsquo;s go back and fix the example.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;valgrind/pmemcheck.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ip;
</span></span><span style=display:flex><span>    VALGRIND_PMC_REGISTER_PMEM_MAPPING(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>    ip <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* tell valgrind these flushing steps occurred */</span>
</span></span><span style=display:flex><span>    VALGRIND_PMC_DO_FLUSH(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>    VALGRIND_PMC_DO_FENCE;
</span></span><span style=display:flex><span>    VALGRIND_PMC_DO_COMMIT;
</span></span><span style=display:flex><span>    VALGRIND_PMC_DO_FENCE;
</span></span><span style=display:flex><span>    VALGRIND_PMC_REMOVE_PMEM_MAPPING(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now the output looks more or less like this:</p><pre><code>Number of stores not made persistent: 0
</code></pre><p>Yay! We assigned a value to a stack variable and made sure it stays there, sort of. Firstly, without a fair amount of <a href=https://giphy.com/gifs/rainbow-unicorn-highway-G0nTMRctvIp4Q title=Magic>magic</a>, the stack will not be persistent memory. Secondly, we only informed pmemcheck that the data was made persistent. The macros defined in <code>pmemcheck.h</code>, and I couldn&rsquo;t stress this more, <strong>DO NOT</strong> affect your code in any way. In this example there is no code related to persistence. This is where libraries such as <a href=/pmdk/ title="Persistent Memory Development Kit">PMDK</a> come in. They do all the magic for you. Once again revisiting the example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;valgrind/pmemcheck.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;libpmem.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ip;
</span></span><span style=display:flex><span>    VALGRIND_PMC_REGISTER_PMEM_MAPPING(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>    ip <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    pmem_persist(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>    VALGRIND_PMC_REMOVE_PMEM_MAPPING(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A lot tidier, don&rsquo;t you think? And it has the added bonus of doing the actual persisting. PMDK has full support for pmemcheck and does all the work for you behind the scenes. It will register the persistent memory region on each pool create/open and do the persisting, not to mention the other features such as transactions in pmemobj. By the way, pmemcheck supports transactions as well, but that&rsquo;s a topic for a different blog post.</p><h3 id=advanced-features>Advanced features</h3><p>Pmemcheck does more than just check for non-persistent stores. Depending on the options you run pmemcheck with it can look out for memory overwrites, redundant flushes or unnecessary flushes. These are either data consistency or performance related issues. Let&rsquo;s look at overwrites first, as they are a potential data corruption source and should be carefully analyzed.</p><h4 id=multiple-overwrites>Multiple overwrites</h4><p>Pmemcheck reports a potential data overwrite when you do a store to the same persistent memory area multiple times, before they become persistent. For pmemcheck to report multiple stores, you have to run the tool with the <code>--mult-stores=yes</code> option. Let&rsquo;s look at an example to clarify this issue.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;valgrind/pmemcheck.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ip;
</span></span><span style=display:flex><span>    VALGRIND_PMC_REGISTER_PMEM_MAPPING(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>    ip <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    ip <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    VALGRIND_PMC_REMOVE_PMEM_MAPPING(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You can see that the value of <code>ip</code> got modified again before it was made persistent. This means, that in case of failure, you can get either value. The problem goes however a little deeper - why would you overwrite <code>ip</code> in the first place? That is something you would do with volatile memory and it means you should probably take it outside of persistent memory. Pmemcheck reports this issue in the following way:</p><pre><code>Number of overwritten stores: 1
Overwritten stores before they were made persistent:
[0]    at 0x400794: main (example.c:7)
       Address: 0xfff000104	size: 4	state: DIRTY
</code></pre><p>Once again, if available, you get the full stacktrace which points to the store that got overwritten. In this example this would be the statement <code>ip = 5;</code>. Sometimes however, Valgrind reports multiple stores to pmemcheck (pmemcheck is a plug-in tool within Valgrind) on calls such as libc <code>memcpy()</code>. This isn&rsquo;t something you need to bother yourself with, you have no control over it. Therefore the need to inform pmemcheck to ignore such occurrences. Here the <code>--indiff</code> comes in handy. Valgrind has this notion of SuperBlocks - to put it simply, these are larger chunks of your code fed to pmemcheck for instrumentation. The <code>--indiff</code> option takes as its parameter, the number of blocks within which, stores made to the same place, with the same size and value will be ignored. This sounds complicated, but let&rsquo;s consider the previous example with a small modification.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;valgrind/pmemcheck.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ip;
</span></span><span style=display:flex><span>    VALGRIND_PMC_REGISTER_PMEM_MAPPING(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>    ip <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    ip <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    VALGRIND_PMC_REMOVE_PMEM_MAPPING(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now let&rsquo;s run this with <code>--indiff=1</code> and see what comes out.</p><pre><code>Number of stores not made persistent: 1
Stores not made persistent properly:
[0]    at 0x40079B: main (example.c:8)
       Address: 0xfff000104	size: 4	state: DIRTY
Total memory not made persistent: 4
</code></pre><p>This is the whole report. I omitted this part previously, because it was irrelevant to the example. As you can see, you don&rsquo;t get the <em>overwritten stores</em> message anymore. The value passed to the <code>--indiff</code> option is somewhat of a guess game. It&rsquo;s hard to determine how far apart different parts of your code will be in Valgrind&rsquo;s internal representation. Internally Valgrind changes your code to an intermediate representation (RISC-like) - you can read more <a href=https://www.valgrind.org/docs/pubs.html title="Valgrind Research Papers">here</a> if you&rsquo;re interested. Seeing as these statements are adjacent, I made an educated guess and decided to go with <em>1</em>.</p><h4 id=flushing-errors>Flushing errors</h4><p>These are strictly performance related, no consistency issue can be observed. As there is nothing complicated here, we&rsquo;ll start of with an example.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;valgrind/pmemcheck.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;libpmem.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ip;
</span></span><span style=display:flex><span>    VALGRIND_PMC_REGISTER_PMEM_MAPPING(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>    ip <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* double flush */</span>
</span></span><span style=display:flex><span>    pmem_flush(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>    pmem_flush(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* nothing to flush */</span>
</span></span><span style=display:flex><span>    pmem_flush((<span style=color:#f92672>&amp;</span>ip <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>), <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>    VALGRIND_PMC_REMOVE_PMEM_MAPPING(<span style=color:#f92672>&amp;</span>ip, <span style=color:#66d9ef>sizeof</span> (ip));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When you run this example with <code>--flush-check=yes</code> you get the following output:</p><pre tabindex=0><code>    Number of redundantly flushed stores: 1
    Stores flushed multiple times:
    [0]    at 0x4007B5: main (example.c:8)
           Address: 0xfff00005c	size: 4	state: FLUSHED

    Number of unnecessary flushes: 1
    [0]    at 0x4008F9: main (example.c:13)
           Address: 0xfff000060	size: 4
</code></pre><p>The first message tells you that you flushed the first store twice (you get one occurrence for each redundant flush). Flushing something more than once doesn&rsquo;t make it more flushed. It does however waste CPU time. The second error informs you that you flushed something that wasn&rsquo;t <em>dirty</em> - there was no store made to that region of persistent memory. Once again this only wastes precious CPU cycles. As I mentioned before, the reported flushing errors only inform you of places you could correct to make your application run a little faster.</p><p>This concludes the introduction to basic and advanced features of pmemcheck. In the next blog post I will explain how the built-in transaction support in pmemcheck works.</p><h6 id=this-entry-was-edited-on-2017-12-11-to-reflect-the-name-change-from-nvml-to-pmdkblog201712announcing-the-persistent-memory-development-kit>[This entry was edited on 2017-12-11 to reflect the name change from <a href=/blog/2017/12/announcing-the-persistent-memory-development-kit>NVML to PMDK</a>.]</h6><div class=clear></div><div class="si-share border-0 d-flex justify-content-between align-items-center"><span>Share this Post:</span><div id=share-buttons><div class="social-icon si-borderless si-facebook" title="Share this on Facebook" onclick='window.open("http://www.facebook.com/share.php?u=https://pmem.io/blog/2015/07/an-introduction-to-pmemcheck-part-1-basics/")'><i class=icon-facebook></i>
<i class=icon-facebook></i></div><div class="social-icon si-borderless si-twitter" title="Share this on Twitter" onclick='window.open("http://twitter.com/intent/tweet?text=An introduction to pmemcheck (part 1) - basics&url=https://pmem.io/blog/2015/07/an-introduction-to-pmemcheck-part-1-basics/")'><i class=icon-twitter></i>
<i class=icon-twitter></i></div><div class="social-icon si-borderless si-linkedin" title="Share this on Linkedin" onclick='window.open("https://www.linkedin.com/shareArticle?mini=true&url=https://pmem.io/blog/2015/07/an-introduction-to-pmemcheck-part-1-basics/&title=&summary=&source=")'><i class=icon-linkedin></i>
<i class=icon-linkedin></i></div><div class="social-icon si-borderless si-pinterest" title="Share this on Pinterest" onclick='window.open("https://pinterest.com/pin/create/button/?url=&media=&description=")'><i class=icon-pinterest></i>
<i class=icon-pinterest></i></div><div class="social-icon si-borderless si-email3" title="Share this through Email" onclick='window.open("mailto:?&body=https://pmem.io/blog/2015/07/an-introduction-to-pmemcheck-part-1-basics/")'><i class=icon-email3></i>
<i class=icon-email3></i></div></div></div></div></div><div class="row justify-content-between col-mb-30 post-navigation"><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2015/07/an-introduction-to-pmemcheck-part-2-transactions/?ref=footer">&lArr; An introduction to pmemcheck...</a></div><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-7-persistent-lists/?ref=footer">An introduction to pmemobj... &rArr;</a></div></div><div class=line></div><h4>Related Posts:</h4><div class="related-posts row posts-md col-mb-30"></div></div></div><div class="sidebar col-lg-3"><div class=sidebar-widgets-wrap><div class="widget clearfix"><h4>Tag Cloud</h4><div class=tagcloud><a href=/tags/pmem class=block role=button>pmem</a>
<a href=/tags/persistent-memory class=block role=button>persistent-memory</a>
<a href=/tags/ndctl class=block role=button>ndctl</a>
<a href=/tags/pmdk class=block role=button>pmdk</a>
<a href=/tags/cxl class=block role=button>cxl</a>
<a href=/tags/daxctl class=block role=button>daxctl</a>
<a href=/tags/memkind class=block role=button>memkind</a>
<a href=/tags/async class=block role=button>async</a>
<a href=/tags/asynchronous class=block role=button>asynchronous</a>
<a href=/tags/concurrency class=block role=button>concurrency</a>
<a href=/tags/configure class=block role=button>configure</a>
<a href=/tags/dax class=block role=button>dax</a>
<a href=/tags/install class=block role=button>install</a>
<a href=/tags/intro class=block role=button>intro</a>
<a href=/tags/miniasync class=block role=button>miniasync</a>
<a href=/tags/setup class=block role=button>setup</a>
<a href=/tags/dml class=block role=button>dml</a>
<a href=/tags/dsa class=block role=button>dsa</a>
<a href=/tags/faq class=block role=button>faq</a>
<a href=/tags/imdb class=block role=button>imdb</a>
<a href=/tags/memory class=block role=button>memory</a>
<a href=/tags/pmem-use-case class=block role=button>pmem-use-case</a>
<a href=/tags/pmem2 class=block role=button>pmem2</a>
<a href=/tags/sanitize class=block role=button>sanitize</a>
<a href=/tags/secure-erase class=block role=button>secure-erase</a>
<a href=/tags/sql class=block role=button>sql</a>
<a href=/tags/tiering class=block role=button>tiering</a>
<a href=/tags/2019 class=block role=button>2019</a>
<a href=/tags/blogs class=block role=button>blogs</a>
<a href=/tags/crash class=block role=button>crash</a></div></div></div></div></div></div></div></section><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2023 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>