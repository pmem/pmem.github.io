<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="pmemobjfs - The simple FUSE based on libpmemobj"><meta property="og:description" content="How to use it The sources of the pmemobjfs file system are available here. Please refer to README file for instructions on how to create a file system layout and mount it.
NOTE: This is just an example implementation of file system in user space using the libpmemobj library and it is not considered to be production quality. Please do not use this file system to store your data you care about because it may be lost."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/blog/2015/09/pmemobjfs-the-simple-fuse-based-on-libpmemobj/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2015-09-29T19:55:17-07:00"><meta property="article:modified_time" content="2015-09-29T19:55:17-07:00"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>pmemobjfs - The simple FUSE based on libpmemobj</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=content><div class="content-wrap dark-mode"><div class="container clearfix"><div class="row gutter-40 col-mb-80"><div class="postcontent col-lg-9 order-lg-last"><div class="single-post mb-0"><div class="entry clearfix"><div class=entry-title><h2>pmemobjfs - The simple FUSE based on libpmemobj</h2></div><div class=entry-meta><ul><li><i class=icon-calendar3></i> 29 Sep, 2015</li><li><i class=icon-user></i> Plebioda</li><li><i class=icon-folder-open></i>
Pmemobjfs</li></ul></div><div class="entry-content mt-0"><h3 id=how-to-use-it>How to use it</h3><p>The sources of the <strong>pmemobjfs</strong> file system are available
<a href=https://github.com/pmem/pmdk/tree/master/src/examples/libpmemobj/pmemobjfs>here</a>. Please refer
to <a href=https://github.com/pmem/pmdk/blob/master/src/examples/libpmemobj/pmemobjfs/README>README</a>
file for instructions on how to create a file system layout and mount it.</p><p><strong>NOTE:</strong> This is just an example implementation of file system in user space using
the <strong>libpmemobj</strong> library and it is <strong>not</strong> considered to be <em>production quality</em>.
<strong>Please do not use this file system to store your data you care about
because it may be lost.</strong></p><h3 id=layout>Layout</h3><p>The definition of <strong>libpmemobj</strong> layout looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>uint8_t</span> objfs_block_t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>POBJ_LAYOUT_BEGIN(pmemobjfs);
</span></span><span style=display:flex><span>POBJ_LAYOUT_ROOT(pmemobjfs, <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_super</span>);
</span></span><span style=display:flex><span>POBJ_LAYOUT_TOID(pmemobjfs, <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_inode</span>);
</span></span><span style=display:flex><span>POBJ_LAYOUT_TOID(pmemobjfs, <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_dir_entry</span>);
</span></span><span style=display:flex><span>POBJ_LAYOUT_TOID(pmemobjfs, objfs_block_t);
</span></span><span style=display:flex><span>POBJ_LAYOUT_TOID(pmemobjfs, <span style=color:#66d9ef>char</span>);
</span></span><span style=display:flex><span>POBJ_LAYOUT_END(pmemobjfs);
</span></span></code></pre></div><p>It consists of a <em>root object</em> and four <em>typed OIDs</em>. The <code>objfs_block_t</code> is
a typedef for the <code>uint8_t</code> type in order to bind an unique type number for
this data structure. The <em>typed OID</em> for a <code>char</code> is required in order to
allocate a fixed-length string from <strong>pmemobj</strong> pool. The rest of data
structures are described in details in the following chapters.</p><h3 id=data-structures>Data structures</h3><h4 id=superblock>Superblock</h4><p>The main data structure of the <strong>pmemobjfs</strong> is the <code>struct objfs_super</code> which
plays a role of a super-block in traditional file systems:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_super</span> {
</span></span><span style=display:flex><span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_inode</span>) root_inode; <span style=color:#75715e>/* root dir inode */</span>
</span></span><span style=display:flex><span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>tree_map</span>) opened; <span style=color:#75715e>/* map of opened files/dirs */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint64_t</span> block_size; <span style=color:#75715e>/* size of data block */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The <code>root_inode</code> field holds the inode object of the root directory which is
created during creation of the file system layout.</p><p>The <code>block_size</code> field holds the size of data block which the files content and
directory entries are stored in.</p><p>The <code>opened</code> field is a <a href=/blog/2015/07/transactional-key-value-store-using-libpmemobj-diy/>tree map</a>
of opened inodes. This map is required for handling the <strong>unlink</strong> operation on
opened files.</p><h4 id=inode>Inode</h4><p>The next important data structure used by the <strong>pmemobjfs</strong> is the
<code>struct objfs_inode</code> which represents a file system object.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_inode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> size; <span style=color:#75715e>/* size of file */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> flags; <span style=color:#75715e>/* file flags */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> dev; <span style=color:#75715e>/* device info */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> ctime; <span style=color:#75715e>/* time of last status change */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> mtime; <span style=color:#75715e>/* time of last modification */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> atime; <span style=color:#75715e>/* time of last access */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> uid; <span style=color:#75715e>/* user ID */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> gid; <span style=color:#75715e>/* group ID */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> ref; <span style=color:#75715e>/* reference counter */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_file</span> file; <span style=color:#75715e>/* file specific data */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_dir</span> dir; <span style=color:#75715e>/* directory specific data */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_symlink</span> symlink; <span style=color:#75715e>/* symlink specific data */</span>
</span></span><span style=display:flex><span>    } d;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>It contains basic attributes of an object:</p><ul><li>file type and permissions flags,</li><li>major and minor device numbers,</li><li>time of last status change,</li><li>time of last modification,</li><li>time of last access (currently this field is not updated),</li><li>user ID of owner,</li><li>group ID of owner,</li><li>number of references.</li></ul><p>The inode may represent a file, directory or a symbolic link. It contains a
separate structures for each inode type which holds essential information about
the specific type of inode:</p><h5 id=directory>Directory:</h5><p>The data specific for directory object contains a doubly-linked list of
directory entries.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_dir</span> {
</span></span><span style=display:flex><span>    PDLL_HEAD(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_dir_entry</span>) entries; <span style=color:#75715e>/* directory entries */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h5 id=file>File:</h5><p>The data specific for file object contains a
<a href=/blog/2015/07/transactional-key-value-store-using-libpmemobj-diy>tree map</a> of blocks. The map key consist
of block number and the value contains a <strong>PMEMoid</strong> to the data block.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_file</span> {
</span></span><span style=display:flex><span>    TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>tree_map</span>) blocks; <span style=color:#75715e>/* blocks map */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h5 id=symbolic-link>Symbolic link:</h5><p>The data specific for symbolic link contains a length of link and the link data.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_symlink</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> len; <span style=color:#75715e>/* length of symbolic link */</span>
</span></span><span style=display:flex><span>    TOID(<span style=color:#66d9ef>char</span>) name; <span style=color:#75715e>/* symbolic link data */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=directory-entry>Directory entry</h4><p>The <code>struct objfs_dir_entry</code> represents a directory entry. It contains a
persistent pointers to the neighbours, a pointer to corresponding inode and
a name:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_dir_entry</span> {
</span></span><span style=display:flex><span>    PDLL_ENTRY(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_dir_entry</span>) pdll; <span style=color:#75715e>/* list entry */</span>
</span></span><span style=display:flex><span>    TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_inode</span>) inode; <span style=color:#75715e>/* pointer to inode */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> name[]; <span style=color:#75715e>/* name */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The maximum length of the name of a directory entry is forced by the block size
specified when creating a file system. It is equal to
<code>block_size - sizeof (struct objfs_dir_entry)</code>.</p><h3 id=operations>Operations</h3><p>All operations which modifies the file system structure are performed within a
transaction, which protects the <strong>pmemobjfs</strong> layout from being broken if power
failure occurred during any operation.</p><p>In this chapter I would like to describe in details some of the most important
operations performed on the file system.</p><p><strong>NOTE:</strong> In current implementation it is recommended to mount the <strong>pmemobjfs</strong>
with the <em>-s</em> option. In this case the <strong>FUSE</strong> works in single-threaded mode
and there is no need for synchronization mechanisms.</p><h4 id=creating-file-system-layout>Creating file system layout</h4><p>To create the <strong>pmemobjfs</strong> layout you can use the <code>mkfs.pmemobjfs</code> command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkfs.pmemobjfs -s &lt;size&gt; -b &lt;block size&gt; /mnt/pmem/pmemobjfs.obj
</span></span></code></pre></div><p>By default it creates a file system layout with the minimal size required for
<strong>pmemobj</strong> pool and with block size equal to <code>512 - 64</code>. The default value for
block size is chosen to such value in order to minimize the internal
fragmentation of allocated blocks. We must keep in mind the fact that in current
implementation the allocation and out-of-band headers are kept in one cache
line before the allocation. Although the default value is chosen with respect
to the internal layout of the <strong>pmemobj</strong> pool, it is not required to keep it in
mind when creating the file system. An arbitrary value specified for the block
size is valid and the <strong>pmemobjfs</strong> will work properly.</p><p>The file system layout is created within a transaction. The following listing
shows the most important parts of the routing for creating the <strong>pmemobjfs</strong>
layout:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>...
</span></span><span style=display:flex><span>objfs<span style=color:#f92672>-&gt;</span>pop <span style=color:#f92672>=</span> pmemobj_create(fname, POBJ_LAYOUT_NAME(pmemobjfs), size, mode);
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_super</span>) super <span style=color:#f92672>=</span> POBJ_ROOT(objfs<span style=color:#f92672>-&gt;</span>pop, <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_super</span>);
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>TX_BEGIN(objfs<span style=color:#f92672>-&gt;</span>pop) {
</span></span><span style=display:flex><span>    TX_ADD(super);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* create an opened files map */</span>
</span></span><span style=display:flex><span>    tree_map_new(objfs<span style=color:#f92672>-&gt;</span>pop, <span style=color:#f92672>&amp;</span>D_RW(super)<span style=color:#f92672>-&gt;</span>opened);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* create root inode, inherit uid and gid from current user */</span>
</span></span><span style=display:flex><span>    D_RW(super)<span style=color:#f92672>-&gt;</span>root_inode <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    	pmemobjfs_new_dir(objfs, TOID_NULL(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_inode</span>),
</span></span><span style=display:flex><span>    			<span style=color:#e6db74>&#34;/&#34;</span>, root_flags, uid, gid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    D_RW(super)<span style=color:#f92672>-&gt;</span>block_size <span style=color:#f92672>=</span> bsize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} TX_ONABORT {
</span></span><span style=display:flex><span>    fprintf(stderr, <span style=color:#e6db74>&#34;error: creating pmemobjfs aborted</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> (<span style=color:#f92672>-</span>ECANCELED);
</span></span><span style=display:flex><span>} TX_END
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>pmemobj_close(objfs<span style=color:#f92672>-&gt;</span>pop);
</span></span></code></pre></div><p>At the beginning the <strong>pmemobj</strong> pool is created with specified name of layout,
size and mode. Next the <em>root object</em> is allocated when calling the <code>POBJ_ROOT</code>
macro for the first time. According to the documentation we can be sure the
root object is zeroed. Next the <em>root object</em> is initialized within a
transaction. The <em>tree map</em> is created for opened inodes, the root inode is
created and the block size is stored. Due to the fact that all operations
are performed within the transaction we can be sure that either the
<em>root object</em> will be filled up entirely or won&rsquo;t be at all. At the very end the
<strong>pmemobj</strong> pool is closed and as a result we have a <strong>pmemobjfs</strong> file system
layout initialized.</p><h4 id=creating-new-directory>Creating new directory</h4><p>The following listing presents the most important operations performed when
creating new directory on <strong>pmemobjfs</strong> file system:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>...
</span></span><span style=display:flex><span>TX_BEGIN(objfs<span style=color:#f92672>-&gt;</span>pop) {
</span></span><span style=display:flex><span>    TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_inode</span>) new_inode <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>        pmemobjfs_new_dir(objfs, inode, name, flags, uid, gid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_dir_entry</span>) entry <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    	pmemobjfs_dir_entry_alloc(objfs, name, new_inode);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pmemobjfs_add_dir_entry(objfs, inode, entry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TX_ADD_FIELD(inode, mtime);
</span></span><span style=display:flex><span>    D_RW(inode)<span style=color:#f92672>-&gt;</span>mtime <span style=color:#f92672>=</span> time(NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} TX_ONABORT {
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> (<span style=color:#f92672>-</span>ECANCELED);
</span></span><span style=display:flex><span>} TX_END
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>After beginning a new transaction the new directory is allocated and
initialized. After creating the inode with new directory, the
<code>struct objfs_dir_entry</code> is allocated with the specified name and associated
newly created inode. The new directory entry is then added to the current
directory&rsquo;s doubly-linked list of entries and modification time is updated.</p><p>The <code>pmemobjfs_new_dir</code> function is presented on the following listing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TX_BEGIN(objfs<span style=color:#f92672>-&gt;</span>pop) {
</span></span><span style=display:flex><span>    inode <span style=color:#f92672>=</span> pmemobjfs_inode_alloc(objfs, flags, uid, gid, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pmemobjfs_inode_init_dir(objfs, inode);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* add . and .. to new directory */</span>
</span></span><span style=display:flex><span>    TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_dir_entry</span>) dot <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    	pmemobjfs_dir_entry_alloc(objfs, <span style=color:#e6db74>&#34;.&#34;</span>, inode);
</span></span><span style=display:flex><span>    TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_dir_entry</span>) dotdot <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    	pmemobjfs_dir_entry_alloc(objfs, <span style=color:#e6db74>&#34;..&#34;</span>, parent);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pmemobjfs_add_dir_entry(objfs, inode, dot);
</span></span><span style=display:flex><span>    pmemobjfs_add_dir_entry(objfs, inode, dotdot);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} TX_ONABORT {
</span></span><span style=display:flex><span>    inode <span style=color:#f92672>=</span> TOID_NULL(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>objfs_inode</span>);
</span></span><span style=display:flex><span>} TX_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> inode;
</span></span></code></pre></div><p>First of all the new inode is allocated with specified permissions and
ownership and the directory specific data of inode is initialized.
Next the current and parent directory entries are allocated and added to the
newly created directory. Everything is done within a transaction. In this case
the transaction will be nested because this function is called from inside
other transaction, but according to the <strong>libpmemobj</strong> documentation if the
outer transaction aborts all changes made within a nested transaction will be
rolled back as well so we do not need to worry about committing the nested
transaction before committing the outermost one.</p><h4 id=allocating-file-blocks>Allocating file blocks</h4><p>The next interesting operation is allocating the file blocks. The following
listing shows how it is implemented:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TX_BEGIN(objfs<span style=color:#f92672>-&gt;</span>pop) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* allocate blocks from requested range */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> b_off <span style=color:#f92672>=</span> offset <span style=color:#f92672>/</span> objfs<span style=color:#f92672>-&gt;</span>block_size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> e_off <span style=color:#f92672>=</span> (offset <span style=color:#f92672>+</span> size) <span style=color:#f92672>/</span> objfs<span style=color:#f92672>-&gt;</span>block_size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint64_t</span> off <span style=color:#f92672>=</span> b_off; off <span style=color:#f92672>&lt;=</span> e_off; off <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        pmemobjfs_file_get_block_for_write(objfs, inode, off);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    time_t t <span style=color:#f92672>=</span> time(NULL);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* update modification time */</span>
</span></span><span style=display:flex><span>    TX_ADD_FIELD(inode, mtime);
</span></span><span style=display:flex><span>    D_RW(inode)<span style=color:#f92672>-&gt;</span>mtime <span style=color:#f92672>=</span> t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* update status change time */</span>
</span></span><span style=display:flex><span>    TX_ADD_FIELD(inode, ctime);
</span></span><span style=display:flex><span>    D_RW(inode)<span style=color:#f92672>-&gt;</span>ctime <span style=color:#f92672>=</span> t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* update inode size */</span>
</span></span><span style=display:flex><span>    D_RW(inode)<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> offset <span style=color:#f92672>+</span> size;
</span></span><span style=display:flex><span>    TX_ADD_FIELD(inode, size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} TX_ONABORT {
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> (<span style=color:#f92672>-</span>ECANCELED);
</span></span><span style=display:flex><span>} TX_END
</span></span></code></pre></div><p>The most important function is <code>pmemobjfs_file_get_block_for_write</code> which
either allocates new block or returns previously allocated block. In the latter
case the previously allocated block is added to the transaction&rsquo;s undo log in
order to track all file&rsquo;s modifications. The following listing shows the
implementation of this function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TOID(objfs_block_t) block <span style=color:#f92672>=</span> pmemobjfs_file_get_block(objfs, inode, offset);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (TOID_IS_NULL(block)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TX_BEGIN(objfs<span style=color:#f92672>-&gt;</span>pop) {
</span></span><span style=display:flex><span>        block <span style=color:#f92672>=</span> TX_ALLOC(objfs_block_t,
</span></span><span style=display:flex><span>        objfs<span style=color:#f92672>-&gt;</span>block_size);
</span></span><span style=display:flex><span>        tree_map_insert(objfs<span style=color:#f92672>-&gt;</span>pop, D_RW(inode)<span style=color:#f92672>-&gt;</span>file.blocks,
</span></span><span style=display:flex><span>        GET_KEY(offset), block.oid);
</span></span><span style=display:flex><span>    } TX_ONABORT {
</span></span><span style=display:flex><span>        block <span style=color:#f92672>=</span> TOID_NULL(objfs_block_t);
</span></span><span style=display:flex><span>    } TX_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    TX_ADD(block);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> block;
</span></span></code></pre></div><p>The <code>pmemobjfs_file_get_block</code> function returns a block at given offset or
returns <code>OID_NULL</code> if the block is missing.
The <code>pmemobjfs_file_get_block_for_write</code> and <code>pmemobjfs_file_get_block</code>
functions are used in <strong>write</strong> and <strong>read</strong> operations respectively when operating
on file&rsquo;s data.</p><h4 id=unlinking-inode>Unlinking inode</h4><p>The <strong>unlink</strong> operation utilizes two interesting mechanisms implemented with
the <strong>pmemobjfs</strong>. The first one is the inode&rsquo;s reference counter which is
increased each time the given inode is referenced by other data structure.
The inode is freed when the reference counter is equal to zero. The functions
which operates on inode&rsquo;s reference counter are <code>pmemobjfs_inode_get</code> and
<code>pmemobjfs_inode_put</code>.</p><p>The <strong>unlink</strong> operation is really simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TX_BEGIN(objfs<span style=color:#f92672>-&gt;</span>pop) {
</span></span><span style=display:flex><span>    pmemobjfs_remove_dir_entry(objfs, inode, entry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TX_ADD_FIELD(inode, size);
</span></span><span style=display:flex><span>    D_RW(inode)<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} TX_ONABORT {
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> (<span style=color:#f92672>-</span>ECANCELED);
</span></span><span style=display:flex><span>} TX_END
</span></span></code></pre></div><p>All the work is performed by the <code>pmemobjfs_remove_dir_entry</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TX_BEGIN(objfs<span style=color:#f92672>-&gt;</span>pop) {
</span></span><span style=display:flex><span>    pmemobjfs_inode_put(objfs, D_RO(entry)<span style=color:#f92672>-&gt;</span>inode);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    PDLL_REMOVE(D_RW(inode)<span style=color:#f92672>-&gt;</span>dir.entries, entry, pdll);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pmemobjfs_dir_entry_free(objfs, entry);
</span></span><span style=display:flex><span>} TX_END
</span></span></code></pre></div><p>The reference counter is decreased and the directory entry is removed from
the doubly-linked list of current directory and freed. The inode is freed if the
reference counter becomes zero after calling the <code>pmemobjfs_inode_put</code> function.</p><p>In case of unlinking an opened file the inode will not be freed immediately
because the <em>open</em> operation increases the inode&rsquo;s reference counter and
adds the inode to the <em>tree map</em> of opened inodes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TX_BEGIN(objfs<span style=color:#f92672>-&gt;</span>pop) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* insert inode to opened inodes map */</span>
</span></span><span style=display:flex><span>    tree_map_insert(objfs<span style=color:#f92672>-&gt;</span>pop, D_RW(super)<span style=color:#f92672>-&gt;</span>opened,
</span></span><span style=display:flex><span>    inode.oid.off, inode.oid);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* hold inode */</span>
</span></span><span style=display:flex><span>    pmemobjfs_inode_get(objfs, inode);
</span></span><span style=display:flex><span>} TX_ONABORT {
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> (<span style=color:#f92672>-</span>ECANCELED);
</span></span><span style=display:flex><span>} TX_END
</span></span></code></pre></div><p>Using those two mechanism it is really simple to implement the <strong>unlink</strong>
operations with respect to opened files or directories and creating hard links.</p><p>Please note that hard links are not implemented currently due to some problems
with the <em>FUSE</em> kernel module which cause the appropriate callback function
is not called.</p><h3 id=transactions>Transactions</h3><p>The <strong>pmemobjfs</strong> provides a feature of creating transactions. The current
implementation is limited to creating a single transaction at a time for the
whole file system, but this feature could be extended to more transactions, for
specified directories or files. The transaction is controlled via the ioctl
calls. For simplicity there have been developed three simple commands which do
the required work:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pmemobjfs.tx_begin
</span></span><span style=display:flex><span>pmemobjfs.tx_abort
</span></span><span style=display:flex><span>pmemobjfs.tx_end
</span></span></code></pre></div><p>For the above commands the path to the <strong>pmemobjfs</strong> mount point or any other
directory must be given. After beginning the transaction all modifications
performed on the file system files, directories or links are tracked by the
<strong>libpmemobj</strong> transactions. It tracks all changes of attributes and data.
They are made persistent after calling the <code>pmemobjfs.tx_commit</code> command.
All changes are visible immediately to the user but can be rolled back simply by
calling the <code>pmemobjfs.tx_abort</code> command. The transaction can be aborted
implicitly if any exceptional situation occurred like for example out of memory
error when allocating file block.</p><p><strong>NOTE:</strong> Aborting the transaction when other process is still working on
the file system may lead to undefined behavior. For example if a new file
was created within a transaction and the transaction is aborted while some
other process is writing to the file leads to undefined behavior.</p><h3 id=performance-results>Performance results</h3><p>In this section I would like to present some performance tests results executed
using the <strong>fio</strong> utility with the following configuration file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[job1]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ioengine</span><span style=color:#f92672>=</span><span style=color:#e6db74>sync</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>runtime</span><span style=color:#f92672>=</span><span style=color:#e6db74>60</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>time_based</span><span style=color:#f92672>=</span><span style=color:#e6db74>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>filesize</span><span style=color:#f92672>=</span><span style=color:#e6db74>128M</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>bs</span><span style=color:#f92672>=</span><span style=color:#e6db74>448</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rw</span><span style=color:#f92672>=</span><span style=color:#e6db74>randrw</span>
</span></span></code></pre></div><p>The block size value has been chosen in order to minimize internal
fragmentation on <strong>pmemobjfs</strong> file system.</p><p>The tests were run on <strong>Fedora 22</strong> distribution, kernel version 4.2.0
with <strong>DAX</strong> support and on the <strong>pmem</strong> block device.</p><p>The tests were run on the following file systems:</p><ul><li>ext4 + dax</li><li>fusexmp_fh + ext4 + dax</li><li>pmemobjfs</li><li>pmemobjfs (NTB)</li></ul><p>The <em>pmemobjfs (NTB)</em> is a <strong>pmemobjfs</strong> version without tracking file blocks
(PMEMOBJFS_TRACK_BLOCKS=0).
The <strong>fusexmp_fh</strong> is a file system which redirects all operations to the
root file system. It is available in the <a href=https://sourceforge.net/projects/fuse/>FUSE</a>
examples.</p><p>The results are presented in the following table:</p><table><thead><tr><th>FS</th><th>READ BW [KB/s]</th><th>WRITE BW [KB/s]</th></tr></thead><tbody><tr><td>ext4 + dax</td><td>232030</td><td>231333</td></tr><tr><td>fusexmp_fh + ext4 + dax</td><td>28687</td><td>28602</td></tr><tr><td>pmemobjfs</td><td>29120</td><td>29034</td></tr><tr><td>pmemobjfs (NTB)</td><td>30112</td><td>30023</td></tr></tbody></table><p>The results shows quite huge overhead from the <strong>FUSE</strong> itself, but it shows
that <strong>pmemobjfs</strong> has slightly better performance than the <strong>fusexmp_fh</strong>
example file system which is quite good information for us :).</p><h3 id=summary>Summary</h3><p>The <strong>pmemobjfs</strong> example shows how the <strong>libpmemobj</strong> API works in a real
application. It can be used to run some performance tests using well known
file system test suites. If you have any questions or ideas for improvement
of the <strong>pmemobjfs</strong> please feel free to join a discussion on our
<a href=https://groups.google.com/group/pmem>Google Group</a>.</p><h6 id=this-entry-was-edited-on-2017-12-11-to-reflect-the-name-change-from-nvml-to-pmdkblog201712announcing-the-persistent-memory-development-kit>[This entry was edited on 2017-12-11 to reflect the name change from <a href=/blog/2017/12/announcing-the-persistent-memory-development-kit>NVML to PMDK</a>.]</h6><div class=clear></div><div class="si-share border-0 d-flex justify-content-between align-items-center"><span>Share this Post:</span><div id=share-buttons><div class="social-icon si-borderless si-facebook" title="Share this on Facebook" onclick='window.open("http://www.facebook.com/share.php?u=https://pmem.io/blog/2015/09/pmemobjfs-the-simple-fuse-based-on-libpmemobj/")'><i class=icon-facebook></i>
<i class=icon-facebook></i></div><div class="social-icon si-borderless si-twitter" title="Share this on Twitter" onclick='window.open("http://twitter.com/intent/tweet?text=pmemobjfs - The simple FUSE based on libpmemobj&url=https://pmem.io/blog/2015/09/pmemobjfs-the-simple-fuse-based-on-libpmemobj/")'><i class=icon-twitter></i>
<i class=icon-twitter></i></div><div class="social-icon si-borderless si-linkedin" title="Share this on Linkedin" onclick='window.open("https://www.linkedin.com/shareArticle?mini=true&url=https://pmem.io/blog/2015/09/pmemobjfs-the-simple-fuse-based-on-libpmemobj/&title=&summary=&source=")'><i class=icon-linkedin></i>
<i class=icon-linkedin></i></div><div class="social-icon si-borderless si-pinterest" title="Share this on Pinterest" onclick='window.open("https://pinterest.com/pin/create/button/?url=&media=&description=")'><i class=icon-pinterest></i>
<i class=icon-pinterest></i></div><div class="social-icon si-borderless si-email3" title="Share this through Email" onclick='window.open("mailto:?&body=https://pmem.io/blog/2015/09/pmemobjfs-the-simple-fuse-based-on-libpmemobj/")'><i class=icon-email3></i>
<i class=icon-email3></i></div></div></div></div></div><div class="row justify-content-between col-mb-30 post-navigation"><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2015/10/evaluation-of-a-better-object-container/?ref=footer">&lArr; Evaluation of a better object...</a></div><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2015/09/challenges-of-multi-threaded-transactions/?ref=footer">Challenges of multi-threaded... &rArr;</a></div></div><div class=line></div><h4>Related Posts:</h4><div class="related-posts row posts-md col-mb-30"></div></div></div><div class="sidebar col-lg-3"><div class=sidebar-widgets-wrap><div class="widget clearfix"><h4>Tag Cloud</h4><div class=tagcloud><a href=/tags/pmem class=block role=button>pmem</a>
<a href=/tags/persistent-memory class=block role=button>persistent-memory</a>
<a href=/tags/ndctl class=block role=button>ndctl</a>
<a href=/tags/pmdk class=block role=button>pmdk</a>
<a href=/tags/cxl class=block role=button>cxl</a>
<a href=/tags/daxctl class=block role=button>daxctl</a>
<a href=/tags/memkind class=block role=button>memkind</a>
<a href=/tags/async class=block role=button>async</a>
<a href=/tags/asynchronous class=block role=button>asynchronous</a>
<a href=/tags/concurrency class=block role=button>concurrency</a>
<a href=/tags/configure class=block role=button>configure</a>
<a href=/tags/dax class=block role=button>dax</a>
<a href=/tags/install class=block role=button>install</a>
<a href=/tags/intro class=block role=button>intro</a>
<a href=/tags/miniasync class=block role=button>miniasync</a>
<a href=/tags/setup class=block role=button>setup</a>
<a href=/tags/dml class=block role=button>dml</a>
<a href=/tags/dsa class=block role=button>dsa</a>
<a href=/tags/faq class=block role=button>faq</a>
<a href=/tags/imdb class=block role=button>imdb</a>
<a href=/tags/memory class=block role=button>memory</a>
<a href=/tags/pmem-use-case class=block role=button>pmem-use-case</a>
<a href=/tags/pmem2 class=block role=button>pmem2</a>
<a href=/tags/sanitize class=block role=button>sanitize</a>
<a href=/tags/secure-erase class=block role=button>secure-erase</a>
<a href=/tags/sql class=block role=button>sql</a>
<a href=/tags/tiering class=block role=button>tiering</a>
<a href=/tags/2019 class=block role=button>2019</a>
<a href=/tags/blogs class=block role=button>blogs</a>
<a href=/tags/crash class=block role=button>crash</a></div></div></div></div></div></div></div></section><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2023 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>