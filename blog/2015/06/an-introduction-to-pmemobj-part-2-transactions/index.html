<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="An introduction to pmemobj (part 2) - transactions"><meta property="og:description" content="By now you should be fairly familiar with the basics persistent memory programming, but to make sure the application is always in a consistent state you had to rely on your own solutions and tricks - like the length of a buffer in the previous example. Now, we will learn a generic solution provided by pmemobj to this type of problems - transactions. For now we will focus on a single-threaded applications with no locking."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-2-transactions/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2015-06-15T19:55:17-07:00"><meta property="article:modified_time" content="2015-06-15T19:55:17-07:00"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>An introduction to pmemobj (part 2) - transactions</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=content><div class="content-wrap dark-mode"><div class="container clearfix"><div class="row gutter-40 col-mb-80"><div class="postcontent col-lg-9 order-lg-last"><div class="single-post mb-0"><div class="entry clearfix"><div class=entry-title><h2>An introduction to pmemobj (part 2) - transactions</h2></div><div class=entry-meta><ul><li><i class=icon-calendar3></i> 15 Jun, 2015</li><li><i class=icon-user></i> Pbalcer</li><li><i class=icon-folder-open></i>
Libpmemobj</li></ul></div><div class="entry-content mt-0"><p>By now you should be fairly familiar with the basics persistent memory programming, but to make sure the application is always in a consistent state you had to rely on your own solutions and tricks - like the length of a buffer in the previous example. Now, we will learn a generic solution provided by pmemobj to this type of problems - transactions. For now we will focus on a single-threaded applications with no locking.</p><h3 id=the-lifecycle>The lifecycle</h3><p>Transactions are managed by the usage of <code>pmemobj_tx_*</code> family of functions. A single transaction goes through a series of stages listed in <code>enum pobj_tx_stage</code> and illustrated by the following diagram:</p><p><img src=/images/posts/lifecycle.png alt=lifecycle></p><p>You can see here how to use each of the stage-managing functions. The <code>pmemobj_tx_process</code> function can be used <strong>instead</strong> of others to move the transaction forward - you can call it if you don&rsquo;t know in which stage you are currently in. All of this can get fairly complicated, for more information please check out the <a href=/pmdk/manpages/linux/master/libpmemobj/libpmemobj.7.html>manpage</a>. To avoid having to micro-manage this entire process the pmemobj library provides a set of macros that are built on top of these functions that greatly simplify using the transactions and this tutorial will exclusively use them.
So, this is how an entire transaction block looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>/* TX_STAGE_NONE */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TX_BEGIN(pop) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* TX_STAGE_WORK */</span>
</span></span><span style=display:flex><span>} TX_ONCOMMIT {
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* TX_STAGE_ONCOMMIT */</span>
</span></span><span style=display:flex><span>} TX_ONABORT {
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* TX_STAGE_ONABORT */</span>
</span></span><span style=display:flex><span>} TX_FINALLY {
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* TX_STAGE_FINALLY */</span>
</span></span><span style=display:flex><span>} TX_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* TX_STAGE_NONE */</span>
</span></span></code></pre></div><p>As you can see this is very closely correlated with the lifecycle diagram, and pretty much self-explanatory. All of the code blocks apart from the <code>TX_BEGIN</code> and <code>TX_END</code> are optional. You can also nest transactions without any limits, and I guess recursive transactions are also <em>technically</em> OK. If a nested transaction aborts, the entire transaction aborts.</p><p>You might wonder why there&rsquo;s the <code>TX_FINALLY</code> stage, why not just execute that code after the transaction block - well, due to the way our transactions work (<code>setjmp</code> at the begin and <code>longjmp</code> on all aborts), you are not guaranteed that the code that is directly after the <code>TX_END</code> in a nested transaction is going to execute at all. Consider the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>do_work</span>() {
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>my_task</span> <span style=color:#f92672>*</span>task <span style=color:#f92672>=</span> malloc(<span style=color:#66d9ef>sizeof</span> <span style=color:#f92672>*</span>task);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (task <span style=color:#f92672>==</span> NULL) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TX_BEGIN(pop) {
</span></span><span style=display:flex><span>    	<span style=color:#75715e>/* important work */</span>
</span></span><span style=display:flex><span>    	pmemobj_tx_abort(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    } TX_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    free(task);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>TX_BEGIN(pop)
</span></span><span style=display:flex><span>do_work();
</span></span><span style=display:flex><span>TX_END
</span></span></code></pre></div><p>This snippet has a memory leak. The <code>free</code> will never be called, because the <code>TX_END</code> in <code>do_work</code> will eventually make a <code>longjmp</code> back to the outer transaction. The correct way of implementing the <code>do_work</code> is to use <code>TX_FINALLY</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>do_work</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>my_task</span> <span style=color:#f92672>*</span>task <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TX_BEGIN(pop) {
</span></span><span style=display:flex><span>    	task <span style=color:#f92672>=</span> malloc(<span style=color:#66d9ef>sizeof</span> <span style=color:#f92672>*</span>task);
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>if</span> (task <span style=color:#f92672>==</span> NULL) pmemobj_tx_abort(ENOMEM);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    	<span style=color:#75715e>/* important work */</span>
</span></span><span style=display:flex><span>    	pmemobj_tx_abort(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    } TX_FINALLY {
</span></span><span style=display:flex><span>    	free(task);
</span></span><span style=display:flex><span>    } TX_END
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is OK because it&rsquo;s guaranteed that the finally block will always be executed.</p><p>Please also note the usage of <code>volatile</code>-qualified variable in TX_FINALLY block.
This is because local non-volatile qualified objects have undefined values after
execution of longjmp if their value have changed after setjmp. So in the case
of libpmemobj transaction blocks every local variable modified in TX_STAGE_WORK and used in
TX_STAGE_ONABORT/TX_STAGE_FINALLY needs to be volatile-qualified - otherwise you might
encounter undefined behavior. Please see the CAVEATS section in libpmemobj
<a href=/pmdk/manpages/linux/master/libpmemobj/pmemobj_tx_begin.3#caveats>manpage</a> for more information.</p><h3 id=transactional-operations>Transactional operations</h3><p>Our library distinguishes 3 different transactional operations: allocation, free and set. Right now we will learn only about the last one, which - as the name suggests, is used to safely <em>set</em> a memory block to some value. This is realized by 2 API functions: <code>pmemobj_tx_add_range</code> and <code>pmemobj_tx_add_range_direct</code>. Quoting the documentation:</p><blockquote><p>Takes a &ldquo;snapshot&rdquo; of the memory block &mldr; and saves it in the undo log.
The application is then free to directly modify the object in that memory range. In case of failure or abort, all the changes within this range will be rolled-back automatically.</p></blockquote><p>What this means is that when you call any of those two functions, a new object is allocated and the existing content of the memory range is copied into it. Unless the library needs that old memory in the transaction rollback, that object will be discarded.
Also, note that the library assumes that when you add the memory range you intend to write to it and the memory is automatically persisted when committing the transaction - so you don&rsquo;t have to call <code>pmemobj_persist</code> yourself.</p><p>So how to use those functions? The <code>pmemobj_tx_add_range</code> takes a raw persistent memory pointer (PMEMoid), an offset from it and its size. So let&rsquo;s set some values inside this structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>vector</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> y;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> z;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PMEMoid root <span style=color:#f92672>=</span> pmemobj_root(pop, <span style=color:#66d9ef>sizeof</span> (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>vector</span>));
</span></span></code></pre></div><p>The naive way of doing it might look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>vector</span> <span style=color:#f92672>*</span>vectorp <span style=color:#f92672>=</span> pmemobj_direct(root);
</span></span><span style=display:flex><span>TX_BEGIN(pop) {
</span></span><span style=display:flex><span>	pmemobj_tx_add_range(root, offsetof(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>vector</span>, x), <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>	vectorp<span style=color:#f92672>-&gt;</span>x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pmemobj_tx_add_range(root, offsetof(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>vector</span>, y), <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>    vectorp<span style=color:#f92672>-&gt;</span>y <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pmemobj_tx_add_range(root, offsetof(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>vector</span>, z), <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>    vectorp<span style=color:#f92672>-&gt;</span>z <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} TX_END
</span></span></code></pre></div><p>But this isn&rsquo;t very optimal - you are adding three objects to the undo log. I think it&rsquo;s sufficient to say that a single undo log entry has size equal to, at <strong>minimum</strong>, 128 bytes. It is way better to just add the entire object at once:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>vector</span> <span style=color:#f92672>*</span>vectorp <span style=color:#f92672>=</span> pmemobj_direct(root);
</span></span><span style=display:flex><span>TX_BEGIN(pop) {
</span></span><span style=display:flex><span>	pmemobj_tx_add_range(root, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>vector</span>));
</span></span><span style=display:flex><span>	vectorp<span style=color:#f92672>-&gt;</span>x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>	vectorp<span style=color:#f92672>-&gt;</span>y <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>	vectorp<span style=color:#f92672>-&gt;</span>z <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>;
</span></span><span style=display:flex><span>} TX_END
</span></span></code></pre></div><p>This way you don&rsquo;t waste unnecessary memory for metadata and the effect will be exactly the same. And it even looks better.</p><p>The <code>pmemobj_tx_add_range_direct</code> does the same thing, but in a more convenient way for some uses. It takes a direct reference to a field and its size, for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>vector</span> <span style=color:#f92672>*</span>vectorp <span style=color:#f92672>=</span> pmemobj_direct(root);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>to_modify <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>vectorp<span style=color:#f92672>-&gt;</span>x;
</span></span><span style=display:flex><span>TX_BEGIN(pop) {
</span></span><span style=display:flex><span>	pmemobj_tx_add_range_direct(to_modify, <span style=color:#66d9ef>sizeof</span> (<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span>to_modify <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>} TX_END
</span></span></code></pre></div><p>This is useful when you don&rsquo;t have an easy way of accessing the PMEMoid this memory block belongs to.</p><h3 id=conditional-transaction-blocks>Conditional transaction blocks</h3><p>It might seem that <code>TX_ONCOMMIT</code> and <code>TX_ONABORT</code> explanation isn&rsquo;t really required, one is called when the transaction commits and the other one when it aborts - simple as that. As long as there are no inner transactions, that is true. But once we start nesting, things get a little bit more complicated. Consider the following example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#define MAX_HASHMAP 1000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>hash_entry</span>) hashmap[MAX_HASHMAP]; <span style=color:#75715e>/* volatile hashmap */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hash_set</span>(<span style=color:#66d9ef>int</span> key, <span style=color:#66d9ef>int</span> value) {
</span></span><span style=display:flex><span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>hash_entry</span>) nentry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TX_BEGIN(pop) {
</span></span><span style=display:flex><span>    	nentry <span style=color:#f92672>=</span> TX_NEW(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>hash_entry</span>);
</span></span><span style=display:flex><span>    	D_RW(nentry)<span style=color:#f92672>-&gt;</span>key <span style=color:#f92672>=</span> key;
</span></span><span style=display:flex><span>    	D_RW(nentry)<span style=color:#f92672>-&gt;</span>value <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>    } TX_ONCOMMIT {
</span></span><span style=display:flex><span>    	size_t hash <span style=color:#f92672>=</span> hash_func(key);
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>if</span> (TOID_IS_NULL(hashmap[hash]))
</span></span><span style=display:flex><span>    		hashmap[hash] <span style=color:#f92672>=</span> nentry;
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    		<span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span>    } TX_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TX_BEGIN(pop) {
</span></span><span style=display:flex><span>	hash_set(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>	pmemobj_tx_abort(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>} TX_END
</span></span></code></pre></div><p>So, a hashmap with entries in persistent memory but with a volatile table containing them. Is this code correct? Well, the <code>hash_set</code> on its own is perfectly OK - but not inside another transaction. When the <code>pmemobj_tx_abort</code> function is called everything in the <code>TX_BEGIN</code> block is reverted but the <code>TX_ONCOMMIT</code> of the nested transaction was already executed (and the <code>TX_ONABORT</code> won&rsquo;t be called in that function), the end result is an invalid persistent pointer in the volatile table. This is generally difficult to solve and requires per-problem solution - I recommend designing your applications to actively avoid it. For this specific use case you can have an extra <code>hash_revert_previous</code> function that is called from the <code>TX_ONABORT</code> block of the outer-most transaction.</p><p>The intended use of the <code>TX_ONCOMMIT</code> and <code>TX_ONABORT</code> is to print log information and set return variable of the function with nested transaction, like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>do_work</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> ret;
</span></span><span style=display:flex><span>	TX_BEGIN(pop) {
</span></span><span style=display:flex><span>	} TX_ONABORT {
</span></span><span style=display:flex><span>		LOG_ERR(<span style=color:#e6db74>&#34;work transaction failed&#34;</span>);
</span></span><span style=display:flex><span>		ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	} TX_ONCOMMIT {
</span></span><span style=display:flex><span>		LOG(<span style=color:#e6db74>&#34;work transaction successful&#34;</span>);
</span></span><span style=display:flex><span>		ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	} TX_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=example>Example</h3><p>We are going to modify the previous example to use a transaction instead of storing the length of a buffer. Open the <code>writer.c</code> and modify the lines after scanf to look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TX_BEGIN(pop) {
</span></span><span style=display:flex><span>	pmemobj_tx_add_range(root, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>my_root</span>));
</span></span><span style=display:flex><span>	memcpy(rootp<span style=color:#f92672>-&gt;</span>buf, buf, strlen(buf));
</span></span><span style=display:flex><span>} TX_END
</span></span></code></pre></div><p>And that&rsquo;s about it, looks simpler right? And more similar to how a volatile program might do this. The <code>reader.c</code> doesn&rsquo;t change much, just remove the <code>if</code> statement that checks the buffer length and you are good to go. If you are having trouble correctly modifying the code, you can find the complete example <a href=https://github.com/pmem/pmdk/tree/master/src/examples/libpmemobj/>here</a>.</p><p>This can be further simplified by combining the two lines inside the transaction together - but that&rsquo;s the topic for our next post.</p><h6 id=this-entry-was-edited-on-2017-12-11-to-reflect-the-name-change-from-nvml-to-pmdkblog201712announcing-the-persistent-memory-development-kit>[This entry was edited on 2017-12-11 to reflect the name change from <a href=/blog/2017/12/announcing-the-persistent-memory-development-kit>NVML to PMDK</a>.]</h6><div class=clear></div><div class="si-share border-0 d-flex justify-content-between align-items-center"><span>Share this Post:</span><div id=share-buttons><div class="social-icon si-borderless si-facebook" title="Share this on Facebook" onclick='window.open("http://www.facebook.com/share.php?u=https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-2-transactions/")'><i class=icon-facebook></i>
<i class=icon-facebook></i></div><div class="social-icon si-borderless si-twitter" title="Share this on Twitter" onclick='window.open("http://twitter.com/intent/tweet?text=An introduction to pmemobj (part 2) - transactions&url=https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-2-transactions/")'><i class=icon-twitter></i>
<i class=icon-twitter></i></div><div class="social-icon si-borderless si-linkedin" title="Share this on Linkedin" onclick='window.open("https://www.linkedin.com/shareArticle?mini=true&url=https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-2-transactions/&title=&summary=&source=")'><i class=icon-linkedin></i>
<i class=icon-linkedin></i></div><div class="social-icon si-borderless si-pinterest" title="Share this on Pinterest" onclick='window.open("https://pinterest.com/pin/create/button/?url=&media=&description=")'><i class=icon-pinterest></i>
<i class=icon-pinterest></i></div><div class="social-icon si-borderless si-email3" title="Share this through Email" onclick='window.open("mailto:?&body=https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-2-transactions/")'><i class=icon-email3></i>
<i class=icon-email3></i></div></div></div></div></div><div class="row justify-content-between col-mb-30 post-navigation"><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-3-types/?ref=footer">&lArr; An introduction to pmemobj...</a></div><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-1-accessing-the-persistent-memory/?ref=footer">An introduction to pmemobj... &rArr;</a></div></div><div class=line></div><h4>Related Posts:</h4><div class="related-posts row posts-md col-mb-30"><div class="entry col-12 col-md-6"><div class="grid-inner row align-items-center gutter-20"><div class=col-4><div class=entry-image><a href=https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-1-accessing-the-persistent-memory/ data-lightbox=image><img src=/images/pmem_logo.png alt="An introduction to pmemobj (part 1) - accessing the persistent memory"></a></div></div><div class=col-8><div class="entry-title title-xs"><h3><a href=https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-1-accessing-the-persistent-memory/>An introduction to pmemobj (part 1) - accessing the persistent memory</a></h3></div><div class=entry-meta><ul><li><i class=icon-user></i> Pbalcer</li><li><i class=icon-calendar3></i> 13 Jun, 2015</li></ul></div></div></div></div></div></div></div><div class="sidebar col-lg-3"><div class=sidebar-widgets-wrap><div class="widget clearfix"><h4>Tag Cloud</h4><div class=tagcloud><a href=/tags/pmem class=block role=button>pmem</a>
<a href=/tags/persistent-memory class=block role=button>persistent-memory</a>
<a href=/tags/ndctl class=block role=button>ndctl</a>
<a href=/tags/pmdk class=block role=button>pmdk</a>
<a href=/tags/cxl class=block role=button>cxl</a>
<a href=/tags/daxctl class=block role=button>daxctl</a>
<a href=/tags/memkind class=block role=button>memkind</a>
<a href=/tags/async class=block role=button>async</a>
<a href=/tags/asynchronous class=block role=button>asynchronous</a>
<a href=/tags/concurrency class=block role=button>concurrency</a>
<a href=/tags/configure class=block role=button>configure</a>
<a href=/tags/dax class=block role=button>dax</a>
<a href=/tags/install class=block role=button>install</a>
<a href=/tags/intro class=block role=button>intro</a>
<a href=/tags/miniasync class=block role=button>miniasync</a>
<a href=/tags/setup class=block role=button>setup</a>
<a href=/tags/dml class=block role=button>dml</a>
<a href=/tags/dsa class=block role=button>dsa</a>
<a href=/tags/faq class=block role=button>faq</a>
<a href=/tags/imdb class=block role=button>imdb</a>
<a href=/tags/memory class=block role=button>memory</a>
<a href=/tags/pmem-use-case class=block role=button>pmem-use-case</a>
<a href=/tags/pmem2 class=block role=button>pmem2</a>
<a href=/tags/sanitize class=block role=button>sanitize</a>
<a href=/tags/secure-erase class=block role=button>secure-erase</a>
<a href=/tags/sql class=block role=button>sql</a>
<a href=/tags/tiering class=block role=button>tiering</a>
<a href=/tags/2019 class=block role=button>2019</a>
<a href=/tags/blogs class=block role=button>blogs</a>
<a href=/tags/crash class=block role=button>crash</a></div></div></div></div></div></div></div></section><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2023 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>