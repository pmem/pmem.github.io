<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="Type safety macros in libpmemobj"><meta property="og:description" content="The PMEMoid plays the role of a persistent pointer in a pmemobj pool. It consist of a shortened UUID of the pool which the object comes from and an offset relative to the beginning of the pool:
typedef struct pmemoid { uint64_t pool_uuid_lo; uint64_t off; } PMEMoid; Operating on such persistent pointers is equivalent to operating on raw pointers to volatile objects represented by void *. This approach is error prone and such errors are very hard to find."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/blog/2015/06/type-safety-macros-in-libpmemobj/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2015-06-11T19:55:17-07:00"><meta property="article:modified_time" content="2015-06-11T19:55:17-07:00"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>Type safety macros in libpmemobj</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=content><div class="content-wrap dark-mode"><div class="container clearfix"><div class="row gutter-40 col-mb-80"><div class="postcontent col-lg-9 order-lg-last"><div class="single-post mb-0"><div class="entry clearfix"><div class=entry-title><h2>Type safety macros in libpmemobj</h2></div><div class=entry-meta><ul><li><i class=icon-calendar3></i> 11 Jun, 2015</li><li><i class=icon-user></i> Plebioda</li><li><i class=icon-folder-open></i>
Macros</li></ul></div><div class="entry-content mt-0"><p>The <em>PMEMoid</em> plays the role of a persistent pointer in a <em>pmemobj</em> pool.
It consist of a shortened UUID of the pool which the object comes from and an
offset relative to the beginning of the pool:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pmemoid</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> pool_uuid_lo;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> off;
</span></span><span style=display:flex><span>} PMEMoid;
</span></span></code></pre></div><p>Operating on such <em>persistent pointers</em> is equivalent to operating on raw
pointers to volatile objects represented by void *. This approach is error
prone and such errors are very hard to find.</p><p>There is a real need to provide some mechanism which would associate
a persistent pointer with a type. The <em>libpmemobj</em> provides a set
of macros which allows to avoid such situations and generates compile-time
errors when trying to assign a <em>PMEMoids</em> of different types.</p><p>As an example it is totally acceptable to perform the following operation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>PMEMoid car <span style=color:#f92672>=</span> pmemobj_tx_alloc(pop, <span style=color:#66d9ef>sizeof</span> (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>), TYPE_CAR);
</span></span><span style=display:flex><span>PMEMoid pen <span style=color:#f92672>=</span> pmemobj_tx_alloc(pop, <span style=color:#66d9ef>sizeof</span> (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pen</span>), TYPE_PEN);
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>car <span style=color:#f92672>=</span> pen;
</span></span></code></pre></div><p>This code compiles fine, however the programmer probably didn&rsquo;t intend for
that that to happen and it will probably lead to hard to debug unexpected
behavior.</p><p>Another problem with untyped pointers is accessing the fields of a structure or
a union. To do this it is required to convert a <em>PMEMoid</em> to a pointer of the
desired type and only after that the fields may be accessed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>PMEMoid car;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span> <span style=color:#f92672>*</span>carp <span style=color:#f92672>=</span> pmemobj_direct(car);
</span></span><span style=display:flex><span>carp<span style=color:#f92672>-&gt;</span>velocity <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span></code></pre></div><p>This leads to a situation where each object must have two representations in
the code: the <em>PMEMoid</em> and a typed pointer.</p><h4 id=anonymous-unions>Anonymous unions</h4><p>One of the possible solutions is to use anonymous unions which contain the
<em>PMEMoid</em> and information about the type of the object - a pointer to the
desired type. This pointer may be used for type checking in assignments and for
conversion from <em>PMEMoid</em> to a pointer of the desired type.</p><p>The macro which declares the anonymous union looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#define OID_TYPE(type)\
</span></span></span><span style=display:flex><span><span style=color:#75715e>union {\
</span></span></span><span style=display:flex><span><span style=color:#75715e>  type *_type;\
</span></span></span><span style=display:flex><span><span style=color:#75715e>  PMEMoid oid;\
</span></span></span><span style=display:flex><span><span style=color:#75715e>}
</span></span></span></code></pre></div><p>When using the <em>OID_TYPE()</em> macro the following code would generate a
compile-time error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>OID_TYPE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car;
</span></span><span style=display:flex><span>OID_TYPE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pen</span>) pen;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>OID_ASSIGN_TYPED(car, pen);
</span></span></code></pre></div><p>The conversion from <em>PMEMoid</em> to the typed pointer may be achieved using the
<em>DIRECT_RW()</em> and <em>DIRECT_RO()</em> macros for read-write and read-only access
respectively:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>OID_TYPE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car1;
</span></span><span style=display:flex><span>OID_TYPE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car2;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>DIRECT_RW(car1)<span style=color:#f92672>-&gt;</span>velocity <span style=color:#f92672>=</span> DIRECT_RO(car2)<span style=color:#f92672>-&gt;</span>velocity <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span></code></pre></div><p>The definition of <em>DIRECT_RW()</em> and <em>DIRECT_RO()</em> macros look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#define DIRECT_RW(o) ((typeof(*(o)._type)*)pmemobj_direct((o).oid)))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define DIRECT_RO(o) ((const typeof (*(o)._type)*)pmemobj_direct((o).oid))
</span></span></span></code></pre></div><h6 id=no-declaration>No declaration</h6><p>Contrary to the later mentioned named unions, the anonymous unions don&rsquo;t need a
declaration. The <em>OID_TYPE()</em> macro may be used for every type at any time.
This makes using the anonymous unions simple and clear.</p><h6 id=assignment>Assignment</h6><p>The assignment of typed persistent pointers must be performed using special
macro. The two anonymous unions which consist of fields with exactly the
same types are not compatible and generates a compilation error:</p><pre tabindex=0><code>    error: incompatible types when assigning to type ‘union &lt;anonymous&gt;’
    from type ‘union &lt;anonymous&gt;’
</code></pre><p>The <code>OID_ASSIGN_TYPED()</code> looks like the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#define OID_ASSIGN_TYPED(lhs, rhs)\
</span></span></span><span style=display:flex><span><span style=color:#75715e>  __builtin_choose_expr(\
</span></span></span><span style=display:flex><span><span style=color:#75715e>  __builtin_types_compatible_p(\
</span></span></span><span style=display:flex><span><span style=color:#75715e>    typeof((lhs)._type),\
</span></span></span><span style=display:flex><span><span style=color:#75715e>    typeof((rhs)._type)),\
</span></span></span><span style=display:flex><span><span style=color:#75715e>  (void) ((lhs).oid = (rhs).oid),\
</span></span></span><span style=display:flex><span><span style=color:#75715e>  (lhs._type = rhs._type))
</span></span></span></code></pre></div><p>It utilizes the gcc builtin operator <em>__builtin_types_compatible_p</em> which checks
the compatibility of types represented by <em>typed persistent pointers</em>. If the
types are compatible the actual assignment is performed. Otherwise the fake
assignment of <em>_type</em> fields is performed in order to get clear message about
the error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>OID_TYPE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car;
</span></span><span style=display:flex><span>OID_TYPE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pen</span>) pen;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>OID_ASSIGN_TYPED(car, pen);
</span></span></code></pre></div><pre tabindex=0><code>    error: assignment from incompatible pointer type [-Werror]
      (lhs._type = rhs._type))
    	       ^
    note: in expansion of macro ‘OID_ASSIGN_TYPED’
     OID_ASSIGN_TYPED(car, pen);
</code></pre><h6 id=passing-typed-persistent-pointer-as-a-function-parameter>Passing typed persistent pointer as a function parameter</h6><p>Passing a typed persistent pointer as a function parameter generates a
compile-time error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stop</span>(OID_TYPE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  D_RW(car)<span style=color:#f92672>-&gt;</span>velocity <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>OID_TYPE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>stop(car);
</span></span></code></pre></div><pre tabindex=0><code>    error: incompatible type for argument 1 of ‘stop’
      stop(car);
      ^
    note: expected ‘union &lt;anonymous&gt;’ but argument is of type
    ‘union &lt;anonymous&gt;’
     stop(OID_TYPE(struct car) car)
</code></pre><h6 id=type-numbers>Type numbers</h6><p>The <em>libpmemobj</em> requires a type number for each allocation. Associating an
unique type number for each type requires to use type numbers as separate
defines or enums when using anonymous unions. It could be possible to embed the
type number in the anonymous union but it would require to pass the type number
every time the <em>OID_TYPE()</em> macro is used.</p><h4 id=named-unions>Named unions</h4><p>The second possible solution for type safety mechanism are named unions.
The idea behind named unions is the same as for anonymous unions but each type
allocated from persistent memory should have a corresponding named union which
holds the <em>PMEMoid</em> and type information.</p><p>The macro which declares the named union may look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#define TOID(type)\
</span></span></span><span style=display:flex><span><span style=color:#75715e>union _toid_##type##_toid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define TOID_DECLARE(type)\
</span></span></span><span style=display:flex><span><span style=color:#75715e>TOID(type)\
</span></span></span><span style=display:flex><span><span style=color:#75715e>{\
</span></span></span><span style=display:flex><span><span style=color:#75715e> PMEMoid oid;\
</span></span></span><span style=display:flex><span><span style=color:#75715e> type *_type;\
</span></span></span><span style=display:flex><span><span style=color:#75715e>}
</span></span></span></code></pre></div><p>The <em>TOID_DECLARE()</em> macro is used to declare a named union which is used as a
<em>typed persistent pointer</em>. The <em>TOID()</em> macro is used to declare a variable
of this type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TOID_DECLARE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>);
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car1;
</span></span><span style=display:flex><span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car2;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>D_RW(car1)<span style=color:#f92672>-&gt;</span>velocity <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> D_RO(car2)<span style=color:#f92672>-&gt;</span>velocity;
</span></span></code></pre></div><p>The name of such a declared union is obtained by concatenating the desired type
name with a <em><em>toid</em></em> prefix and a <em><em>toid</em></em> postfix. The prefix is required to
handle the two token type names like <em>struct name</em>, <em>union name</em> and
<em>enum name</em>. In such case the macro expands to two tokens in which the first
one is declared as an empty macro thus avoiding the compilation errors which
would appear, if only postfix or prefix was used.
For example in case of the <em>struct car</em> the <em>TOID()</em> macro will expand to the
following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>_toid_struct car_toid
</span></span></code></pre></div><p>The <code>_toid_struct</code> token and analogous for <code>enum car</code> and <code>union car</code> may be
removed by declaring the following empty macros:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#define _toid_struct
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define _toid_union
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define _toid_enum
</span></span></span></code></pre></div><p>In result the <em>typed persistent pointer</em> for <em>struct car</em> will be named
<em>car_toid</em>. In case of one-token types the name of union will consist of both
prefix and postfix. For example in case of <em>size_t</em> type, the <em>TOID()</em> macro
will expand to the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>_toid_size_t_toid
</span></span></code></pre></div><p>Using such mechanism it is possible to declare named unions for two-token types.</p><p>The definition of <em>D_RW()</em> and <em>D_RO()</em> macros are the same as in case of
anonymous unions.</p><h6 id=assignment-1>Assignment</h6><p>In case of named unions there is no issue with assignments encountered in
anonymous unions. The assignment may be performed without using any additional
macro:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TOID_DECLARE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>);
</span></span><span style=display:flex><span>TOID_DECLARE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pen</span>);
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car1;
</span></span><span style=display:flex><span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car2;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>car1 <span style=color:#f92672>=</span> car2;
</span></span></code></pre></div><p>The above example compiles without any errors but the following code would
generate an error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TOID_DECLARE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>);
</span></span><span style=display:flex><span>TOID_DECLARE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pen</span>);
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car;
</span></span><span style=display:flex><span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pen</span>) pen;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>car <span style=color:#f92672>=</span> pen;
</span></span></code></pre></div><pre tabindex=0><code>    error: incompatible types when assigning to type ‘union car_toid’ from
    type ‘union pen_toid’
      car = pen;
    	^
</code></pre><p>Which clearly points where the problem is.</p><h6 id=passing-typed-persistent-pointer-as-a-function-parameter-1>Passing typed persistent pointer as a function parameter</h6><p>It is also possible to pass the named union as a function parameter:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TOID_DECLARE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stop</span>(TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  D_RW(car)<span style=color:#f92672>-&gt;</span>velocity <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stop(car);
</span></span></code></pre></div><p>Passing <em>typed persistent pointer</em> of a different type generates a clear error
message:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TOID_DECLARE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>);
</span></span><span style=display:flex><span>TOID_DECLARE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pen</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stop</span>(TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>) car)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  D_RW(car)<span style=color:#f92672>-&gt;</span>velocity <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>..
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TOID(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pen</span>) pen;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stop(pen);
</span></span></code></pre></div><pre tabindex=0><code>    error: incompatible type for argument 1 of ‘stop’
      stop(pen);
</code></pre><h6 id=type-numbers-1>Type numbers</h6><p>Since the named union must be declared before using it, the type number may be
assigned to the type in the declaration. The type number shall be assigned at
compilation time and it can be embedded in the <em>typed persistent pointer</em> by
modifying the <em>TOID_DECLARE()</em> macro:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#define TOID_DECLARE(type, type_num)\
</span></span></span><span style=display:flex><span><span style=color:#75715e>typedef uint8_t _toid_##type##_toid_id[(type_num)];\
</span></span></span><span style=display:flex><span><span style=color:#75715e>TOID(type)\
</span></span></span><span style=display:flex><span><span style=color:#75715e>{\
</span></span></span><span style=display:flex><span><span style=color:#75715e> PMEMoid oid;\
</span></span></span><span style=display:flex><span><span style=color:#75715e> type *_type;\
</span></span></span><span style=display:flex><span><span style=color:#75715e> _toid_##type##_toid_id *_id;\
</span></span></span><span style=display:flex><span><span style=color:#75715e>}
</span></span></span></code></pre></div><p>The type id may be obtained using the <em>sizeof ()</em> operator both from type and an
object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#define TOID_TYPE_ID(type) (sizeof (_toid_##type##_toid_id))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TOID_TYPE_ID_OF(obj) (sizeof (*(obj)._id))
</span></span></span></code></pre></div><p>The declaration of such <em>typed persistent pointer</em> may look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TOID_DECLARE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>TOID_DECLARE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pen</span>, <span style=color:#ae81ff>2</span>);
</span></span></code></pre></div><p>It is also possible to use macros or enums to declare a type id:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>  TYPE_CAR,
</span></span><span style=display:flex><span>  TYPE_PEN
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TOID_DECLARE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>, TYPE_CAR);
</span></span><span style=display:flex><span>TOID_DECLARE(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pen</span>, TYPE_PEN);
</span></span></code></pre></div><p>This solution requires to assign the type id explicitly at declaration time.
Since the set of types allocated from the <em>pmemobj</em> pool is well known at
compilation time it is possible to declare all types by declaring a pool&rsquo;s
layout without explicitly assigning the type id. The layout declaration looks
like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>/* Declaration of layout */</span>
</span></span><span style=display:flex><span>POBJ_LAYOUT_BEGIN(my_layout)
</span></span><span style=display:flex><span>POBJ_LAYOUT_TOID(my_layout, <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>car</span>)
</span></span><span style=display:flex><span>POBJ_LAYOUT_TOID(my_layout, <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pen</span>)
</span></span><span style=display:flex><span>POBJ_LAYOUT_END(my_layout)
</span></span></code></pre></div><p>Using such declaration of layout all types declared inside the
<em>POBJ_LAYOUT_BEGIN()</em> and <em>POBJ_LAYOUT_END()</em> macros will be assigned with
consecutive type ids.</p><h4 id=summary>Summary</h4><p>The following table contains a summary of both described solutions:</p><table><thead><tr><th>Feature</th><th>Anonymous unions</th><th>Named unions</th></tr></thead><tbody><tr><td>Declaration</td><td>+</td><td>-</td></tr><tr><td>Assignment</td><td>-</td><td>+</td></tr><tr><td>Function parameter</td><td>-</td><td>+</td></tr><tr><td>Type numbers</td><td>-</td><td>+</td></tr></tbody></table><div class=clear></div><div class="si-share border-0 d-flex justify-content-between align-items-center"><span>Share this Post:</span><div id=share-buttons><div class="social-icon si-borderless si-facebook" title="Share this on Facebook" onclick='window.open("http://www.facebook.com/share.php?u=https://pmem.io/blog/2015/06/type-safety-macros-in-libpmemobj/")'><i class=icon-facebook></i>
<i class=icon-facebook></i></div><div class="social-icon si-borderless si-twitter" title="Share this on Twitter" onclick='window.open("http://twitter.com/intent/tweet?text=Type safety macros in libpmemobj&url=https://pmem.io/blog/2015/06/type-safety-macros-in-libpmemobj/")'><i class=icon-twitter></i>
<i class=icon-twitter></i></div><div class="social-icon si-borderless si-linkedin" title="Share this on Linkedin" onclick='window.open("https://www.linkedin.com/shareArticle?mini=true&url=https://pmem.io/blog/2015/06/type-safety-macros-in-libpmemobj/&title=&summary=&source=")'><i class=icon-linkedin></i>
<i class=icon-linkedin></i></div><div class="social-icon si-borderless si-pinterest" title="Share this on Pinterest" onclick='window.open("https://pinterest.com/pin/create/button/?url=&media=&description=")'><i class=icon-pinterest></i>
<i class=icon-pinterest></i></div><div class="social-icon si-borderless si-email3" title="Share this through Email" onclick='window.open("mailto:?&body=https://pmem.io/blog/2015/06/type-safety-macros-in-libpmemobj/")'><i class=icon-email3></i>
<i class=icon-email3></i></div></div></div></div></div><div class="row justify-content-between col-mb-30 post-navigation"><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-0-new-programming-model/?ref=footer">&lArr; An introduction to pmemobj...</a></div><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2015/06/implementing-simple-mysql-storage-engine-with-libpmemobj/?ref=footer">Implementing (simple) MySQL... &rArr;</a></div></div><div class=line></div><h4>Related Posts:</h4><div class="related-posts row posts-md col-mb-30"></div></div></div><div class="sidebar col-lg-3"><div class=sidebar-widgets-wrap><div class="widget clearfix"><h4>Tag Cloud</h4><div class=tagcloud><a href=/tags/pmem class=block role=button>pmem</a>
<a href=/tags/persistent-memory class=block role=button>persistent-memory</a>
<a href=/tags/ndctl class=block role=button>ndctl</a>
<a href=/tags/pmdk class=block role=button>pmdk</a>
<a href=/tags/cxl class=block role=button>cxl</a>
<a href=/tags/daxctl class=block role=button>daxctl</a>
<a href=/tags/memkind class=block role=button>memkind</a>
<a href=/tags/async class=block role=button>async</a>
<a href=/tags/asynchronous class=block role=button>asynchronous</a>
<a href=/tags/concurrency class=block role=button>concurrency</a>
<a href=/tags/configure class=block role=button>configure</a>
<a href=/tags/dax class=block role=button>dax</a>
<a href=/tags/install class=block role=button>install</a>
<a href=/tags/intro class=block role=button>intro</a>
<a href=/tags/miniasync class=block role=button>miniasync</a>
<a href=/tags/setup class=block role=button>setup</a>
<a href=/tags/dml class=block role=button>dml</a>
<a href=/tags/dsa class=block role=button>dsa</a>
<a href=/tags/faq class=block role=button>faq</a>
<a href=/tags/imdb class=block role=button>imdb</a>
<a href=/tags/memory class=block role=button>memory</a>
<a href=/tags/pmem-use-case class=block role=button>pmem-use-case</a>
<a href=/tags/pmem2 class=block role=button>pmem2</a>
<a href=/tags/sanitize class=block role=button>sanitize</a>
<a href=/tags/secure-erase class=block role=button>secure-erase</a>
<a href=/tags/sql class=block role=button>sql</a>
<a href=/tags/tiering class=block role=button>tiering</a>
<a href=/tags/2019 class=block role=button>2019</a>
<a href=/tags/blogs class=block role=button>blogs</a>
<a href=/tags/crash class=block role=button>crash</a></div></div></div></div></div></div></div></section><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2023 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>