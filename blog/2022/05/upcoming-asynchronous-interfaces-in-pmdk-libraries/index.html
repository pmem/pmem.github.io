<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="Upcoming asynchronous interfaces in PMDK libraries"><meta property="og:description" content="In the previous article, I wrote about a new upcoming Xeon platform feature, Data Streaming Accelerator (DSA) - a memory-to-memory DMA engine, and what opportunities and challenges it presents. I outlined the approach we are taking in Persistent Memory Development Kit (PMDK) to expose asynchronous APIs that can take advantage of this new hardware. Lastly, I introduced libminiasync, which is our framework for abstracting asynchronous operations.
This time, I will discuss how miniasync is being used in libpmem2 and our plans for its integration into the rest of PMDK libraries."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/blog/2022/05/upcoming-asynchronous-interfaces-in-pmdk-libraries/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-05-11T10:00:00+00:00"><meta property="article:modified_time" content="2022-05-11T10:00:00+00:00"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>Upcoming asynchronous interfaces in PMDK libraries</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=content><div class="content-wrap dark-mode"><div class="container clearfix"><div class="row gutter-40 col-mb-80"><div class="postcontent col-lg-9 order-lg-last"><div class="single-post mb-0"><div class="entry clearfix"><div class=entry-title><h2>Upcoming asynchronous interfaces in PMDK libraries</h2></div><div class=entry-meta><ul><li><i class=icon-calendar3></i> 11 May, 2022</li><li><i class=icon-user></i> Piotr Balcer</li><li><i class=icon-folder-open></i>
PMDK</li></ul></div><div class="entry-content mt-0"><p>In the <a href=https://pmem.io/blog/2022/02/leveraging-asynchronous-hardware-accelerators-for-fun-and-profit/>previous article</a>, I wrote about a new upcoming Xeon platform feature,
Data Streaming Accelerator (DSA) - a memory-to-memory DMA engine, and what opportunities
and challenges it presents. I outlined the approach we are taking in
Persistent Memory Development Kit (PMDK) to expose asynchronous APIs that can
take advantage of this new hardware. Lastly, I introduced libminiasync, which
is our framework for abstracting asynchronous operations.</p><p>This time, I will discuss how miniasync is being used in libpmem2 and our plans for its integration into the rest of PMDK libraries.</p><h2 id=technical-considerations-for-supporting-new-hardware-or-os-features-in-pmdk>Technical considerations for supporting new hardware or OS features in PMDK</h2><p>PMDK is a sizable collection of existing tools and libraries. It supports various
different architectures (x86-64, aarch64, ppc64, riscv64) and systems
(Linux, Windows, FreeBSD). Introducing support for any new hardware or OS features
requires careful deliberation to ensure our software remains usable for our
existing users, no matter the platform they are using or the upgrade path they
are taking. We also need to make sure that any software abstractions for hardware
features we introduce aren&rsquo;t tied to any particular implementation. This is
especially important for any public interfaces since they are hard
to change after release.</p><p>With DSA, we have the perfect storm - it&rsquo;s both a new hardware feature and a
capability that requires a fairly extensive public interface. We also
cannot pick just one software implementation like DML to help us with our
abstraction, since we already know that there are potential users that might
wish to leverage an alternative software layer, like the one provided in SPDK.</p><p><img src=/images/posts/async-2-overview.png alt=overview></p><p>With all that in mind, we&rsquo;ve created miniasync - a fairly generic abstraction
for asynchronous operations. It allows us to create public APIs in PMDK libraries
that operate purely on abstract asynchronous functions, with the actual data
movement implementation provided at runtime by the user. Or not, in which case
a software callback is used.</p><h2 id=integrating-miniasync-with-pmem2>Integrating miniasync with pmem2</h2><p>PMDK is a stack of libraries, one building on top of another. To create highly
elaborate async functionality in the highest layer of that stack, we first need
to enable everything below it, starting from the bottom - libpmem2. It is our
core library that provides the foundations for persistent memory programming. It
abstracts away the memory mapping and flushing primitives, implements
PMem-optimized memory operations like <code>memcpy</code> or <code>memset</code>, and provides
Reliability, Availability, and Serviceability (RAS) APIs.</p><p>As a starting point, we are adding asynchronous <code>memcpy</code>, <code>memmove</code> and <code>memset</code>
APIs to pmem2.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmem2_future <span style=color:#a6e22e>pmem2_memcpy_async</span>(<span style=color:#66d9ef>struct</span> pmem2_map <span style=color:#f92672>*</span>map,
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>pmemdest, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>src, size_t len, <span style=color:#66d9ef>unsigned</span> flags);
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmem2_future <span style=color:#a6e22e>pmem2_memmove_async</span>(<span style=color:#66d9ef>struct</span> pmem2_map <span style=color:#f92672>*</span>map,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>pmemdest, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>src, size_t len, <span style=color:#66d9ef>unsigned</span> flags);
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmem2_future <span style=color:#a6e22e>pmem2_memset_async</span>(<span style=color:#66d9ef>struct</span> pmem2_map <span style=color:#f92672>*</span>map,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>str, <span style=color:#66d9ef>int</span> c, size_t n, <span style=color:#66d9ef>unsigned</span> flags);
</span></span></code></pre></div><p>These functions map the regular synchronous pmem2 primitives onto asynchronous
futures provided by miniasync. But to actually use DSA, or a different
asynchronous data movement engine, users will need to explicitly assign a
virtual data mover (vdm) instance to the pmem2 map.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmem2_config_set_vdm</span>(<span style=color:#66d9ef>struct</span> pmem2_config <span style=color:#f92672>*</span>cfg, <span style=color:#66d9ef>struct</span> vdm <span style=color:#f92672>*</span>vdm);
</span></span></code></pre></div><p>Without this, pmem2 will use a software fallback based on its implementation
of memory operations.</p><p>To use these async functions, the software will need to define <code>PMEM2_USE_MINIASYNC</code>
prior to including pmem2.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define PMEM2_USE_MINIASYNC 1
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;libpmem2.h&#34;</span><span style=color:#75715e>
</span></span></span></code></pre></div><p>This is because we&rsquo;ve made a conscious decision to make this software feature
entirely optional, at least for now. We also made sure that the core miniasync
abstractions (futures, vdm) are header-only. This will make it easier
for existing users to upgrade PMDK version if they don&rsquo;t want miniasync.
It will also make it possible for us to package pmem2 into various linux and
windows repositories without having first to package miniasync.</p><h2 id=future-looking-plans-and-ideas>Future-looking plans and ideas</h2><p>As I&rsquo;ve said above, our work on asynchronous interfaces doesn&rsquo;t stop with pmem2.
We intend on leveraging miniasync throughout the stack of PMDK libraries. The
first example of that is in pmemstream, our work-in-progress solution for
efficient log storage and processing.</p><p>In pmemstream, we want to make a general abstraction for all types of logs. We
also want to make sure that our library doesn&rsquo;t just run on PMem, but also
supports a wider variety of heterogeneous memory and storage systems.
To accomplish that, we are designing our on-media layout in a way that seamlessly
supports <a href=https://www.cs.rochester.edu/u/scott/papers/2016_DISC_persistence.pdf>buffered durable linearizability</a>. This means
that we can make writes fully asynchronous while still making sure that everything
remains consistent, even in the presence of failures. And obviously we are going to
use miniasync to create that asynchronous API.</p><p>Our other plans include using asynchronous APIs in libpmemobj, our transactional
object storage system. One of the enhancements that we are thinking about is
improving our undo and redo logging implementations to allow concurrent processing
of log entries, potentially reducing the time it takes for transactions to be
committed or aborted.</p><p>And, of course, we also want to use miniasync in our user-space block storage
API - libpmemblk.</p><h2 id=asynchronous-block-storage-apis>Asynchronous block storage APIs</h2><p>The pmemblk library is a failure-atomic implementation of a block storage
interface on top of Persistent Memory. This is needed because PMem, unlike
standard enterprise disks, does not provide sector atomicity (because there
are no sectors). If you were to simply create a huge array of blocks and
write to it directly, you might have data consistency issues when the system crashes.
This behavior might be fine for software designed to tolerate failures,
but not for anything else. Our library addresses this problem through the use
of <a href=https://pmem.io/blog/2014/09/using-the-block-translation-table-for-sector-atomicity/>Block Translation Table</a> algorithm.</p><p>However, as I&rsquo;ve described in my <a href=https://pmem.io/blog/2022/02/leveraging-asynchronous-hardware-accelerators-for-fun-and-profit/>first article</a>, using PMem as block
storage has an additional cost of using the CPU to perform the actual
I/O. This also applies to libpmemblk. Thankfully, with DSA and miniasync, we can
address this problem.</p><p><img src=/images/posts/async-2-pmemblk.png alt=overview></p><p>Logically, a write in the BTT algorithm I mentioned earlier is composed
of four steps:</p><ol><li>Allocate a new block for the new write.</li><li>Perform a memory copy to populate the newly allocated block.</li><li>Update metadata, pointing it to the new block.</li><li>Deallocate the previous block for that position.</li></ol><p>To make the API thread-safe, the implementation protects these steps with
a myriad of locks and other concurrency mechanisms.</p><p>Out of these four operations, we want to leverage DSA for the second step, the
memory copy of the data itself. We could do this transparently by simply
replacing memcpy with an async version. But that wouldn&rsquo;t really allow for
concurrency. We need to break-up these steps into individual futures,
so that users can run multiple concurrent block write operations even from
a single thread. Thanks to the miniasync framework, that in itself is not much
of a problem. But we do have to be careful around existing concurrency primitives
and operating system locks - this is because holding a lock across a future boundary
might lead to deadlocks, where a single thread tries to acquire the same lock
twice, but in separate async operations.</p><h2 id=summary>Summary</h2><p>In this blog series, I&rsquo;ve described the PMDK team&rsquo;s efforts to enable DSA in
existing and upcoming libraries. All this work is happening on
our <a href=https://github.com/pmem>github</a>. If you are interested, please take a look around and
let us know what you think. Any feedback we receive from our users is very
valuable to us.</p><div class="tagcloud clearfix bottommargin"><a href=https://pmem.io/tags/miniasync>miniasync</a>
<a href=https://pmem.io/tags/pmem2>pmem2</a>
<a href=https://pmem.io/tags/dml>DML</a>
<a href=https://pmem.io/tags/dsa>DSA</a>
<a href=https://pmem.io/tags/concurrency>concurrency</a>
<a href=https://pmem.io/tags/async>async</a>
<a href=https://pmem.io/tags/asynchronous>asynchronous</a></div><div class=clear></div><div class="si-share border-0 d-flex justify-content-between align-items-center"><span>Share this Post:</span><div id=share-buttons><div class="social-icon si-borderless si-facebook" title="Share this on Facebook" onclick='window.open("http://www.facebook.com/share.php?u=https://pmem.io/blog/2022/05/upcoming-asynchronous-interfaces-in-pmdk-libraries/")'><i class=icon-facebook></i>
<i class=icon-facebook></i></div><div class="social-icon si-borderless si-twitter" title="Share this on Twitter" onclick='window.open("http://twitter.com/intent/tweet?text=Upcoming asynchronous interfaces in PMDK libraries&url=https://pmem.io/blog/2022/05/upcoming-asynchronous-interfaces-in-pmdk-libraries/")'><i class=icon-twitter></i>
<i class=icon-twitter></i></div><div class="social-icon si-borderless si-linkedin" title="Share this on Linkedin" onclick='window.open("https://www.linkedin.com/shareArticle?mini=true&url=https://pmem.io/blog/2022/05/upcoming-asynchronous-interfaces-in-pmdk-libraries/&title=&summary=&source=")'><i class=icon-linkedin></i>
<i class=icon-linkedin></i></div><div class="social-icon si-borderless si-pinterest" title="Share this on Pinterest" onclick='window.open("https://pinterest.com/pin/create/button/?url=&media=&description=")'><i class=icon-pinterest></i>
<i class=icon-pinterest></i></div><div class="social-icon si-borderless si-email3" title="Share this through Email" onclick='window.open("mailto:?&body=https://pmem.io/blog/2022/05/upcoming-asynchronous-interfaces-in-pmdk-libraries/")'><i class=icon-email3></i>
<i class=icon-email3></i></div></div></div></div></div><div class="row justify-content-between col-mb-30 post-navigation"><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2022/06/basic-asynchronous-hashmap-with-miniasync-library/?ref=footer">&lArr; Basic asynchronous hashmap...</a></div><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2022/02/leveraging-asynchronous-hardware-accelerators-for-fun-and-profit/?ref=footer">Leveraging asynchronous... &rArr;</a></div></div><div class=line></div><h4>Related Posts:</h4><div class="related-posts row posts-md col-mb-30"><div class="entry col-12 col-md-6"><div class="grid-inner row align-items-center gutter-20"><div class=col-4><div class=entry-image><a href=https://pmem.io/blog/2022/02/leveraging-asynchronous-hardware-accelerators-for-fun-and-profit/ data-lightbox=image><img src=/images/pmem_logo.png alt="Leveraging asynchronous hardware accelerators for fun and profit"></a></div></div><div class=col-8><div class="entry-title title-xs"><h3><a href=https://pmem.io/blog/2022/02/leveraging-asynchronous-hardware-accelerators-for-fun-and-profit/>Leveraging asynchronous hardware accelerators for fun and profit</a></h3></div><div class=entry-meta><ul><li><i class=icon-user></i> Piotr Balcer</li><li><i class=icon-calendar3></i> 28 Feb, 2022</li></ul></div></div></div></div><div class="entry col-12 col-md-6"><div class="grid-inner row align-items-center gutter-20"><div class=col-4><div class=entry-image><a href=https://pmem.io/blog/2022/01/disaggregated-memory-in-pursuit-of-scale-and-efficiency/ data-lightbox=image><img src=/images/pmem_logo.png alt="Disaggregated Memory - In pursuit of scale and efficiency"></a></div></div><div class=col-8><div class="entry-title title-xs"><h3><a href=https://pmem.io/blog/2022/01/disaggregated-memory-in-pursuit-of-scale-and-efficiency/>Disaggregated Memory - In pursuit of scale and efficiency</a></h3></div><div class=entry-meta><ul><li><i class=icon-user></i> Piotr Balcer</li><li><i class=icon-calendar3></i> 21 Jan, 2022</li></ul></div></div></div></div><div class="entry col-12 col-md-6"><div class="grid-inner row align-items-center gutter-20"><div class=col-4><div class=entry-image><a href=https://pmem.io/blog/2019/10/new-release-of-pmdk/ data-lightbox=image><img src=/images/pmem_logo.png alt="New release of PMDK"></a></div></div><div class=col-8><div class="entry-title title-xs"><h3><a href=https://pmem.io/blog/2019/10/new-release-of-pmdk/>New release of PMDK</a></h3></div><div class=entry-meta><ul><li><i class=icon-user></i> Pbalcer</li><li><i class=icon-calendar3></i> 11 Oct, 2019</li></ul></div></div></div></div><div class="entry col-12 col-md-6"><div class="grid-inner row align-items-center gutter-20"><div class=col-4><div class=entry-image><a href=https://pmem.io/blog/2018/10/new-release-of-pmdk/ data-lightbox=image><img src=/images/pmem_logo.png alt="New release of PMDK"></a></div></div><div class=col-8><div class="entry-title title-xs"><h3><a href=https://pmem.io/blog/2018/10/new-release-of-pmdk/>New release of PMDK</a></h3></div><div class=entry-meta><ul><li><i class=icon-user></i> Pbalcer</li><li><i class=icon-calendar3></i> 22 Oct, 2018</li></ul></div></div></div></div></div></div></div><div class="sidebar col-lg-3"><div class=sidebar-widgets-wrap><div class="widget clearfix"><h4>Tag Cloud</h4><div class=tagcloud><a href=/tags/pmem class=block role=button>pmem</a>
<a href=/tags/persistent-memory class=block role=button>persistent-memory</a>
<a href=/tags/ndctl class=block role=button>ndctl</a>
<a href=/tags/pmdk class=block role=button>pmdk</a>
<a href=/tags/cxl class=block role=button>cxl</a>
<a href=/tags/daxctl class=block role=button>daxctl</a>
<a href=/tags/memkind class=block role=button>memkind</a>
<a href=/tags/async class=block role=button>async</a>
<a href=/tags/asynchronous class=block role=button>asynchronous</a>
<a href=/tags/concurrency class=block role=button>concurrency</a>
<a href=/tags/configure class=block role=button>configure</a>
<a href=/tags/dax class=block role=button>dax</a>
<a href=/tags/install class=block role=button>install</a>
<a href=/tags/intro class=block role=button>intro</a>
<a href=/tags/miniasync class=block role=button>miniasync</a>
<a href=/tags/setup class=block role=button>setup</a>
<a href=/tags/dml class=block role=button>dml</a>
<a href=/tags/dsa class=block role=button>dsa</a>
<a href=/tags/faq class=block role=button>faq</a>
<a href=/tags/imdb class=block role=button>imdb</a>
<a href=/tags/memory class=block role=button>memory</a>
<a href=/tags/pmem-use-case class=block role=button>pmem-use-case</a>
<a href=/tags/pmem2 class=block role=button>pmem2</a>
<a href=/tags/sanitize class=block role=button>sanitize</a>
<a href=/tags/secure-erase class=block role=button>secure-erase</a>
<a href=/tags/sql class=block role=button>sql</a>
<a href=/tags/tiering class=block role=button>tiering</a>
<a href=/tags/2019 class=block role=button>2019</a>
<a href=/tags/blogs class=block role=button>blogs</a>
<a href=/tags/crash class=block role=button>crash</a></div></div></div></div></div></div></div></section><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2023 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>