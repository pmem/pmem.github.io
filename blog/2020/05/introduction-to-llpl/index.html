<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="Introduction to LLPL"><meta property="og:description" content="There are several ways to program with persistent memory from Java. A recent pmem.io blog article described the pmemkv library, a persistent key-value store, which can be used from multiple languages. For Java, pmemkv supports three ubiquitous Java types: String, byte[], and ByteBuffer.
Another PMDK component, the Low-Level Persistence Library (LLPL) is an open source Java library (https://github.com/pmem/llpl) that gives Java developers access to persistent memory in a very fast and flexible way."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/blog/2020/05/introduction-to-llpl/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-05-27T19:55:17-07:00"><meta property="article:modified_time" content="2020-05-27T19:55:17-07:00"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>Introduction to LLPL</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=content><div class="content-wrap dark-mode"><div class="container clearfix"><div class="row gutter-40 col-mb-80"><div class="postcontent col-lg-9 order-lg-last"><div class="single-post mb-0"><div class="entry clearfix"><div class=entry-title><h2>Introduction to LLPL</h2></div><div class=entry-meta><ul><li><i class=icon-calendar3></i> 27 May, 2020</li><li><i class=icon-user></i> Sdohrmann</li><li><i class=icon-folder-open></i>
LLPL</li></ul></div><div class="entry-content mt-0"><p>There are several ways to program with persistent memory from Java. A
<a href=/blog/2020/03/language-bindings-for-pmemkv>recent pmem.io blog article</a>
described the pmemkv library, a persistent key-value store, which can be used
from multiple languages. For Java, pmemkv supports three ubiquitous
Java types: String, byte[], and ByteBuffer.</p><p>Another PMDK component, the Low-Level Persistence Library (LLPL) is an
open source Java library <a href=https://github.com/pmem/llpl>(https://github.com/pmem/llpl)</a> that
gives Java developers access to persistent memory in a very fast and flexible way.
This article will introduce LLPL by way of Java examples that show how
to manage and access persistent memory using the library.</p><p>LLPL offers persistent memory as heaps of memory, separate from the Java
heap and the Java objects that reside there. While LLPL heaps are
separate from the (non-persistent) Java heap, you use regular Java
objects to access persistent memory. You can create LLPL heaps, reopen
them, and delete them. You can create many heaps, of almost any size, as
long as there is unused persistent memory available to create them.</p><p>In Figure 1 below, we see Java Heap and MemoryBlock objects being used
to access LLPL heaps and memory blocks. At any point in time, these Java
access objects are needed only for those heaps and memory blocks that
are actively being accessed. When an access object becomes unreachable
and is collected by Java, nothing happens to the persistent memory;
memory management of LLPL memory blocks is done manually. Likewise,
while the Java heap and all its objects disappear when the Java
application exits, the LLPL heaps, blocks, and relationships between
blocks remain. We&rsquo;ll see later, in code, that it&rsquo;s easy to re-access
LLPL heaps and their memory blocks when your Java application restarts.</p><p><img src=/images/posts/llpl_intro_figure_1.png alt="Figure 1 &amp;ndash; objects on the Java heap used to access persistent memory inLLPL heaps"></p><p>Now we&rsquo;ll walk through some code examples that demonstrate creating
heaps, and reading and writing to blocks of persistent memory.</p><p>To create a heap:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   <span style=color:#66d9ef>long</span> heapSize <span style=color:#f92672>=</span> 100 <span style=color:#f92672>*</span> 1024 <span style=color:#f92672>*</span> 1024<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>   Heap heap <span style=color:#f92672>=</span> Heap<span style=color:#f92672>.</span><span style=color:#a6e22e>createHeap</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/pmem/heap1&#34;</span><span style=color:#f92672>,</span> heapSize<span style=color:#f92672>);</span>
</span></span></code></pre></div><p>This creates a 100 MB heap with the name &ldquo;heap1&rdquo;. The &ldquo;/pmem/&rdquo; portion of
the heap path is an example of a base path where persistent memory was
provisioned on the system. To re-access a heap after a process or
machine restart:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   Heap heap <span style=color:#f92672>=</span> Heap<span style=color:#f92672>.</span><span style=color:#a6e22e>openHeap</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/pmem/heap1&#34;</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>You can delete this heap by deleting the file that names the heap:</p><pre tabindex=0><code>   &gt;rm /pmem/heap1
</code></pre><p>Once you have a heap, the next step is to allocate some part of it for
writing and reading:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   MemoryBlock block1 <span style=color:#f92672>=</span> heap<span style=color:#f92672>.</span><span style=color:#a6e22e>allocateMemoryBlock</span><span style=color:#f92672>(</span>1024<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>This returns a memory block object representing a 1K block of zero&rsquo;d
bytes. The memory block API has setter and getter methods for Java byte,
short, int, and long types, as well as bulk memory copy methods. For
example, to set a long value of 1234 at the first byte in the memory
block:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   block1<span style=color:#f92672>.</span><span style=color:#a6e22e>setLong</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> 1234<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>   block1<span style=color:#f92672>.</span><span style=color:#a6e22e>flush</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> Long<span style=color:#f92672>.</span><span style=color:#a6e22e>BYTES</span><span style=color:#f92672>);</span> <span style=color:#75715e>// flush data to persistent memory modules
</span></span></span></code></pre></div><p>Note the flush call in the second line above. Persistent memory behaves
much like regular DRAM, and programming with it is very similar. The
obvious difference is its persistence, and the flush above is a necessary
operation associated with persistence.</p><p>Like DRAM, persistent memory is &ldquo;cache-coherent virtual memory&rdquo; and
writes to pmem are placed in the CPU cache and made visible to other
threads. Like DRAM, however, flushing writes from the CPU cache to the
actual memory modules may be delayed until the system needs the cache
space. This means that your persistent memory program will behave
correctly when initially run, but some of your writes to pmem may not
have been pushed all the way to the persistent memory modules prior to
your program&rsquo;s exit. In that case, some changes won&rsquo;t be present when
you reopen the heap to access the &ldquo;persistent&rdquo; data. To ensure your
changes make it all the way to the memory modules and are available
after a restart, a flush operation needs to be done, sometime before
your program exits, on those parts of persistent memory that were
modified.</p><p>We&rsquo;ll see later how LLPL can flush writes automatically, but full manual
control of flushing is available as shown above.</p><p>Byte positions within a block are specified using zero-based offsets
from the beginning of the block. You can copy bytes between memory
blocks, or between a memory block and a Java byte array. For example, to
write a length-prefixed string &ldquo;Saturn&rdquo; to the first byte in the memory
block:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   String s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Saturn&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>   block1<span style=color:#f92672>.</span><span style=color:#a6e22e>setInt</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>   block1<span style=color:#f92672>.</span><span style=color:#a6e22e>copyFromArray</span><span style=color:#f92672>(</span>s<span style=color:#f92672>.</span><span style=color:#a6e22e>getBytes</span><span style=color:#f92672>(),</span> 0<span style=color:#f92672>,</span> 4<span style=color:#f92672>,</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>   block1<span style=color:#f92672>.</span><span style=color:#a6e22e>flush</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>BYTES</span> <span style=color:#f92672>+</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span> <span style=color:#75715e>// flush both writes
</span></span></span></code></pre></div><p>After a process exits, the Java objects representing the heap and
allocated blocks are discarded, but the persistent memory remains. A way
to re-access the memory we were using in the last session is needed, and
there are methods in the Heap API that let us do that easily.</p><p>To save a &ldquo;bookmark&rdquo; to a memory block before our process exits, we can
store the name for a memory block, its &ldquo;handle&rdquo;, represented as a Java
long value, in a special named &ldquo;root&rdquo; location in the heap.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   heap<span style=color:#f92672>.</span><span style=color:#a6e22e>setRoot</span><span style=color:#f92672>(</span>block1<span style=color:#f92672>.</span><span style=color:#a6e22e>handle</span><span style=color:#f92672>());</span>
</span></span></code></pre></div><p>To access our heap and our block after a restart:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   Heap heap <span style=color:#f92672>=</span> Heap<span style=color:#f92672>.</span><span style=color:#a6e22e>openHeap</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/pmem/heap1&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>   MemoryBlock block1 <span style=color:#f92672>=</span> heap<span style=color:#f92672>.</span><span style=color:#a6e22e>memoryBlockFromHandle</span><span style=color:#f92672>(</span>heap<span style=color:#f92672>.</span><span style=color:#a6e22e>getRoot</span><span style=color:#f92672>());</span>
</span></span></code></pre></div><p>The second line above wraps a memory block object around the supplied
handle, giving access again to memory associated with the handle. Memory
block handles are stable, and can be safely written as long values into
other memory blocks, in order to link blocks and build reference-based
data structures:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   MemoryBlock block2 <span style=color:#f92672>=</span> heap<span style=color:#f92672>.</span><span style=color:#a6e22e>allocateMemoryBlock</span><span style=color:#f92672>(</span>1024<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>   block1<span style=color:#f92672>.</span><span style=color:#a6e22e>setLong</span><span style=color:#f92672>(</span>100<span style=color:#f92672>,</span> block2<span style=color:#f92672>.</span><span style=color:#a6e22e>handle</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>   block1<span style=color:#f92672>.</span><span style=color:#a6e22e>flush</span><span style=color:#f92672>(</span>100<span style=color:#f92672>,</span> Long<span style=color:#f92672>.</span><span style=color:#a6e22e>BYTES</span><span style=color:#f92672>);</span> <span style=color:#75715e>// flush 8 bytes, handles are Java longs
</span></span></span></code></pre></div><p>When you read a handle from one block and want to access the memory
associated with the handle you read, you pass the handle to the heap&rsquo;s
memoryBlockFromHandle method to get a memory block back:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   <span style=color:#66d9ef>long</span> block2Handle <span style=color:#f92672>=</span> block1<span style=color:#f92672>.</span><span style=color:#a6e22e>getLong</span><span style=color:#f92672>(</span>100<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>   MemoryBlock block2 <span style=color:#f92672>=</span> heap<span style=color:#f92672>.</span><span style=color:#a6e22e>memoryBlockFromHandle</span><span style=color:#f92672>(</span>block2Handle<span style=color:#f92672>);</span>
</span></span></code></pre></div><p>Deallocating a block of memory is done manually by calling its free()
method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   block2<span style=color:#f92672>.</span><span style=color:#a6e22e>free</span><span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>Since we freed block2, its handle is no longer valid, so we will set the
block2 handle we wrote into block1 to zero, an invalid handle value:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   block1<span style=color:#f92672>.</span><span style=color:#a6e22e>setLong</span><span style=color:#f92672>(</span>100<span style=color:#f92672>,</span> 0<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>   block1<span style=color:#f92672>.</span><span style=color:#a6e22e>flush</span><span style=color:#f92672>(</span>100<span style=color:#f92672>,</span> Long<span style=color:#f92672>.</span><span style=color:#a6e22e>BYTES</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>In the examples so far, we have been writing data and flushing the
writes to persistent memory media. Under normal circumstances, this is
all that is required to ensure that your data is intact and usable when
you restart your application and reopen the heap. However, unforeseen
events (e.g. crashes or power failures) can complicate this simple data
integrity scheme. For example, if a memory copy operation happens to get
interrupted by a crash, only part of the data will have been written to
persistent memory, leaving the heap in an inconsistent state. Or, if you
are modifying a linked data structure (e.g. writing data to two
distinct locations in order to insert a node into a linked list) an
interruption can leave your data structure in an un-linked state.</p><p>For cases where the consistency of the heap must be maintained in the
face of such events, LLPL offers transactional operations and user
transactions to provide fail-safe writing to a heap.</p><p>The example below writes a length-prefixed string in a fail-safe way, by
enclosing the writes in a Transaction and specifying which bytes are
modified as part of the transaction.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   String s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Saturn&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>   Transaction<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>heap<span style=color:#f92672>,</span> <span style=color:#f92672>()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      block1<span style=color:#f92672>.</span><span style=color:#a6e22e>addToTransaction</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>BYTES</span> <span style=color:#f92672>+</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>      block1<span style=color:#f92672>.</span><span style=color:#a6e22e>setInt</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>      block1<span style=color:#f92672>.</span><span style=color:#a6e22e>copyFromArray</span><span style=color:#f92672>(</span>s<span style=color:#f92672>.</span><span style=color:#a6e22e>getBytes</span><span style=color:#f92672>(),</span> 0<span style=color:#f92672>,</span> 4<span style=color:#f92672>,</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>});</span>
</span></span></code></pre></div><p>Note the addToTransaction call above. This tells the transaction about a
range of bytes that will be modified as part of the transaction &ndash;
<em>before</em> they are modified. This allows the transaction implementation
to make a backup of those bytes, to be used in restoring the original
data in the event that the transaction is interrupted. Written this way,
the modifications done as part of the transaction will behave as if they
&ldquo;happen as a whole or not at all.&rdquo; Flushing of the modifications is done
automatically by the transaction if the Java lambda expression (the
body of the transaction) executes to completion.</p><p>If the application allows multiple threads to concurrently access a byte
range being modified in a transaction, then in order to maintain correct
transactional behavior, it is important to isolate access to that byte
range for the duration of the transaction. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   String s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Saturn&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>synchronized</span><span style=color:#f92672>(</span>block1<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      Transaction<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>heap<span style=color:#f92672>,</span> <span style=color:#f92672>()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         block1<span style=color:#f92672>.</span><span style=color:#a6e22e>addToTransaction</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>BYTES</span> <span style=color:#f92672>+</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>         block1<span style=color:#f92672>.</span><span style=color:#a6e22e>setInt</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>         block1<span style=color:#f92672>.</span><span style=color:#a6e22e>copyFromArray</span><span style=color:#f92672>(</span>s<span style=color:#f92672>.</span><span style=color:#a6e22e>getBytes</span><span style=color:#f92672>(),</span> 0<span style=color:#f92672>,</span> 4<span style=color:#f92672>,</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>In the examples so far, we have been using general Heap and MemoryBlock
classes. The MemoryBlock API gives manual control over flushing and
adding transaction byte ranges; this gives maximum flexibility, but
requires extra coding and care to not forget these important operations.
With some loss of flexibility, and possibly some loss of performance,
LLPL offers two additional kinds of heaps and corresponding memory
blocks that can be used to automate flushing and adding ranges to a
transaction.</p><p>The PersistentHeap and corresponding PersistentMemoryBlock classes are
very similar to the general Heap and MemoryBlock classes, but they
automate flushing of writes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   PersistentHeap heap <span style=color:#f92672>=</span> PersistentHeap<span style=color:#f92672>.</span><span style=color:#a6e22e>createHeap</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/pmem/heap2&#34;</span><span style=color:#f92672>,</span> heapSize<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>   PersistentMemoryBlock block3 <span style=color:#f92672>=</span> heap<span style=color:#f92672>.</span><span style=color:#a6e22e>allocateMemoryBlock</span><span style=color:#f92672>(</span>1024<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>   String s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Saturn&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>   block3<span style=color:#f92672>.</span><span style=color:#a6e22e>setInt</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>   block3<span style=color:#f92672>.</span><span style=color:#a6e22e>copyFromArray</span><span style=color:#f92672>(</span>s<span style=color:#f92672>.</span><span style=color:#a6e22e>getBytes</span><span style=color:#f92672>(),</span> 0<span style=color:#f92672>,</span> 4<span style=color:#f92672>,</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// both writes are flushed automatically
</span></span></span></code></pre></div><p>In a similar way, if you want all writes on a heap to be transactional,
the TransactionalHeap and corresponding TransactionalMemoryBlock classes
automate the adding of all writes to a transaction, both stand-alone
writes and writes within an explicit transaction body:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   TransactionalHeap heap <span style=color:#f92672>=</span> TransactionalHeap<span style=color:#f92672>.</span><span style=color:#a6e22e>createHeap</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/pmem/heap3&#34;</span><span style=color:#f92672>,</span> heapSize<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>   TransactionalMemoryBlock block4 <span style=color:#f92672>=</span> heap<span style=color:#f92672>.</span><span style=color:#a6e22e>allocateMemoryBlock</span><span style=color:#f92672>(</span>1024<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>   String s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Saturn&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>   Transaction<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>heap<span style=color:#f92672>,</span> <span style=color:#f92672>()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// write ranges will automatically be added to the transaction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      block4<span style=color:#f92672>.</span><span style=color:#a6e22e>setInt</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>      block4<span style=color:#f92672>.</span><span style=color:#a6e22e>copyFromArray</span><span style=color:#f92672>(</span>s<span style=color:#f92672>.</span><span style=color:#a6e22e>getBytes</span><span style=color:#f92672>(),</span> 0<span style=color:#f92672>,</span> 4<span style=color:#f92672>,</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>});</span>
</span></span></code></pre></div><p>Offset-based specification of memory locations, as used in the examples
above, is very flexible but can be tedious and error-prone. Various
techniques can be used to abstract block offsets and hide offset
arithmetic. One such technique is to create a Java class whose named
accessor methods statically refer to specific offsets within a memory
block. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Employee</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> ID <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> NAME_LENGTH <span style=color:#f92672>=</span> 8<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> NAME_BYTES <span style=color:#f92672>=</span> 12<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>private</span> TransactionalMemoryBlock block<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Employee</span><span style=color:#f92672>(</span>TransactionalHeap heap<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> id<span style=color:#f92672>,</span> String name<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         Transaction<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>heap<span style=color:#f92672>,</span> <span style=color:#f92672>()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            block <span style=color:#f92672>=</span> heap<span style=color:#f92672>.</span><span style=color:#a6e22e>allocateMemoryBlock</span><span style=color:#f92672>(</span>8 <span style=color:#f92672>+</span> 4 <span style=color:#f92672>+</span> name<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>            setId<span style=color:#f92672>(</span>id<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            setName<span style=color:#f92672>(</span>name<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>         <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// &#34;reconstruct&#34; an Employee from handle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Employee</span><span style=color:#f92672>(</span>TransactionalHeap heap<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> handle<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>block</span> <span style=color:#f92672>=</span> heap<span style=color:#f92672>.</span><span style=color:#a6e22e>memoryBlockFromHandle</span><span style=color:#f92672>(</span>handle<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>getId</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>return</span> block<span style=color:#f92672>.</span><span style=color:#a6e22e>getLong</span><span style=color:#f92672>(</span>ID<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setId</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> id<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         block<span style=color:#f92672>.</span><span style=color:#a6e22e>setLong</span><span style=color:#f92672>(</span>ID<span style=color:#f92672>,</span> id<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>int</span> nameLength <span style=color:#f92672>=</span> block<span style=color:#f92672>.</span><span style=color:#a6e22e>getInt</span><span style=color:#f92672>(</span>NAME_LENGTH<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[</span>nameLength<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>         block<span style=color:#f92672>.</span><span style=color:#a6e22e>copyToArray</span><span style=color:#f92672>(</span>NAME_BYTES<span style=color:#f92672>,</span> bytes<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> nameLength<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>(</span>bytes<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span><span style=color:#f92672>(</span>String name<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes <span style=color:#f92672>=</span> name<span style=color:#f92672>.</span><span style=color:#a6e22e>getBytes</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>int</span> nameLength <span style=color:#f92672>=</span> bytes<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>         block<span style=color:#f92672>.</span><span style=color:#a6e22e>setInt</span><span style=color:#f92672>(</span>NAME_LENGTH<span style=color:#f92672>,</span> nameLength<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>         block<span style=color:#f92672>.</span><span style=color:#a6e22e>copyFromArray</span><span style=color:#f92672>(</span>bytes<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> NAME_BYTES<span style=color:#f92672>,</span> nameLength<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>free</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         block<span style=color:#f92672>.</span><span style=color:#a6e22e>free</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>handle</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>return</span> block<span style=color:#f92672>.</span><span style=color:#a6e22e>handle</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Using a wrapper object in this way abstracts the allocation, and reading
and writing of persistent data into familiar constructor calls and
method calls:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   Employee e <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Employee<span style=color:#f92672>(</span>heap<span style=color:#f92672>,</span> 12345<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Jupiter&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>long</span> id <span style=color:#f92672>=</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>getId</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>   e<span style=color:#f92672>.</span><span style=color:#a6e22e>setId</span><span style=color:#f92672>(</span>23456<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>   String name <span style=color:#f92672>=</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>   e<span style=color:#f92672>.</span><span style=color:#a6e22e>setName</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Pluto&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>   e<span style=color:#f92672>.</span><span style=color:#a6e22e>free</span><span style=color:#f92672>();</span>
</span></span></code></pre></div><p>Note that management of the persistent memory these wrapper objects
refer to is still manual. There are more complete code samples in the
examples directory in the LLPL GitHub repository at
<a href=https://github.com/pmem/llpl>https://github.com/pmem/llpl</a></p><p>I hope that you found this introduction to LLPL interesting, and that
you explore LLPL further on GitHub.</p><div class=clear></div><div class="si-share border-0 d-flex justify-content-between align-items-center"><span>Share this Post:</span><div id=share-buttons><div class="social-icon si-borderless si-facebook" title="Share this on Facebook" onclick='window.open("http://www.facebook.com/share.php?u=https://pmem.io/blog/2020/05/introduction-to-llpl/")'><i class=icon-facebook></i>
<i class=icon-facebook></i></div><div class="social-icon si-borderless si-twitter" title="Share this on Twitter" onclick='window.open("http://twitter.com/intent/tweet?text=Introduction to LLPL&url=https://pmem.io/blog/2020/05/introduction-to-llpl/")'><i class=icon-twitter></i>
<i class=icon-twitter></i></div><div class="social-icon si-borderless si-linkedin" title="Share this on Linkedin" onclick='window.open("https://www.linkedin.com/shareArticle?mini=true&url=https://pmem.io/blog/2020/05/introduction-to-llpl/&title=&summary=&source=")'><i class=icon-linkedin></i>
<i class=icon-linkedin></i></div><div class="social-icon si-borderless si-pinterest" title="Share this on Pinterest" onclick='window.open("https://pinterest.com/pin/create/button/?url=&media=&description=")'><i class=icon-pinterest></i>
<i class=icon-pinterest></i></div><div class="social-icon si-borderless si-email3" title="Share this through Email" onclick='window.open("mailto:?&body=https://pmem.io/blog/2020/05/introduction-to-llpl/")'><i class=icon-email3></i>
<i class=icon-email3></i></div></div></div></div></div><div class="row justify-content-between col-mb-30 post-navigation"><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2020/08/static-code-analysis-of-the-pmdk/?ref=footer">&lArr; Static code analysis of the...</a></div><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2020/03/300-nanoseconds-2-of-2/?ref=footer">300 nanoseconds (2 of 2) &rArr;</a></div></div><div class=line></div><h4>Related Posts:</h4><div class="related-posts row posts-md col-mb-30"></div></div></div><div class="sidebar col-lg-3"><div class=sidebar-widgets-wrap><div class="widget clearfix"><h4>Tag Cloud</h4><div class=tagcloud><a href=/tags/pmem class=block role=button>pmem</a>
<a href=/tags/persistent-memory class=block role=button>persistent-memory</a>
<a href=/tags/ndctl class=block role=button>ndctl</a>
<a href=/tags/pmdk class=block role=button>pmdk</a>
<a href=/tags/cxl class=block role=button>cxl</a>
<a href=/tags/daxctl class=block role=button>daxctl</a>
<a href=/tags/memkind class=block role=button>memkind</a>
<a href=/tags/async class=block role=button>async</a>
<a href=/tags/asynchronous class=block role=button>asynchronous</a>
<a href=/tags/concurrency class=block role=button>concurrency</a>
<a href=/tags/configure class=block role=button>configure</a>
<a href=/tags/dax class=block role=button>dax</a>
<a href=/tags/install class=block role=button>install</a>
<a href=/tags/intro class=block role=button>intro</a>
<a href=/tags/miniasync class=block role=button>miniasync</a>
<a href=/tags/setup class=block role=button>setup</a>
<a href=/tags/dml class=block role=button>dml</a>
<a href=/tags/dsa class=block role=button>dsa</a>
<a href=/tags/faq class=block role=button>faq</a>
<a href=/tags/imdb class=block role=button>imdb</a>
<a href=/tags/memory class=block role=button>memory</a>
<a href=/tags/pmem-use-case class=block role=button>pmem-use-case</a>
<a href=/tags/pmem2 class=block role=button>pmem2</a>
<a href=/tags/sanitize class=block role=button>sanitize</a>
<a href=/tags/secure-erase class=block role=button>secure-erase</a>
<a href=/tags/sql class=block role=button>sql</a>
<a href=/tags/tiering class=block role=button>tiering</a>
<a href=/tags/2019 class=block role=button>2019</a>
<a href=/tags/blogs class=block role=button>blogs</a>
<a href=/tags/crash class=block role=button>crash</a></div></div></div></div></div></div></div></section><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2023 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>