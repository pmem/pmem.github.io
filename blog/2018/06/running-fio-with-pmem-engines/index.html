<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="Running FIO with pmem engines"><meta property="og:description" content="When we, the PMDK team, want to check performance of our library, either to see if there was any regression or if our tweaks did a good job, we run benchmarks. One of them is FIO. It helps us simulate synthetic traffic of reads and writes to a pmem device. In this blog post I will introduce this tool and explain how we commonly use it.
Preparing the environment For starters, links to needed software:"><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/blog/2018/06/running-fio-with-pmem-engines/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2018-06-25T19:55:17-07:00"><meta property="article:modified_time" content="2018-06-25T19:55:17-07:00"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>Running FIO with pmem engines</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=content><div class="content-wrap dark-mode"><div class="container clearfix"><div class="row gutter-40 col-mb-80"><div class="postcontent col-lg-9 order-lg-last"><div class="single-post mb-0"><div class="entry clearfix"><div class=entry-title><h2>Running FIO with pmem engines</h2></div><div class=entry-meta><ul><li><i class=icon-calendar3></i> 25 Jun, 2018</li><li><i class=icon-user></i> Lukaszstolarczuk</li><li><i class=icon-folder-open></i>
FIO</li></ul></div><div class="entry-content mt-0"><p>When we, the PMDK team, want to check performance of our library, either to see
if there was any regression or if our tweaks did a good job, we run benchmarks.
One of them is FIO. It helps us simulate synthetic traffic of reads and writes
to a pmem device. In this blog post I will introduce this tool and explain how
we commonly use it.</p><h3 id=preparing-the-environment>Preparing the environment</h3><p>For starters, links to needed software:</p><ul><li><a href=https://github.com/axboe/fio>FIO</a></li><li><a href=https://github.com/pmem/ndctl>NDCTL</a></li></ul><p>And, of course, to execute any FIO tests using pmem engines you need PMDK
installed in your system.</p><p>Tests can be run on <a href=/blog/2016/02/how-to-emulate-persistent-memory>emulated pmem</a> or real hardware (devices
presented to system by NVDIMM Firmware Interface Table (NFIT), according to ACPI
Specification v6.0+). Either way you have to prepare device(s) before test
execution. First step is to configure a namespace (emulated pmem is delivered
already as a namespace). For this step you can use command <code>ndctl create-namespace</code>. There are two main options to configure namespace in our
case, either you choose mode <code>fsdax</code> or <code>devdax</code>. Namespace configured with
<strong>fsdax</strong> is a block device with support of dax operations. It can host a
dax-capable file system (e.g. ext4 or xfs) and should be configured like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ndctl create-namespace --type<span style=color:#f92672>=</span>pmem --mode<span style=color:#f92672>=</span>fsdax --region<span style=color:#f92672>=</span>X <span style=color:#f92672>[</span>--align<span style=color:#f92672>=</span>4k<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>mkfs.ext4 /dev/pmemX
</span></span><span style=display:flex><span>mkdir /mnt/pmem
</span></span><span style=display:flex><span>mount /dev/pmemX /mnt/pmem -o dax
</span></span></code></pre></div><p>In all cases regions should be created and maintained using administrative tool
specific for your platform. Optional parameter <strong>align</strong> can be used to change
alignment, while default for both mentioned modes is 2M.</p><p>Namespace with <strong>devdax</strong> mode is a character device and is a raw access
analogue of filesystem-dax. Configuration is simpler, because there&rsquo;s no need
for file system preparation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ndctl create-namespace --type<span style=color:#f92672>=</span>pmem --mode<span style=color:#f92672>=</span>devdax --region<span style=color:#f92672>=</span>X <span style=color:#f92672>[</span>--align<span style=color:#f92672>=</span>4k<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>To sum up, when you execute the following commands:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls /mnt/pmem
</span></span><span style=display:flex><span>ls /dev/dax<span style=color:#ae81ff>\*</span>
</span></span></code></pre></div><p>You should see mounted file system or dev-dax device available to use.</p><h3 id=fio>FIO</h3><p>Installation of FIO is pretty straightforward and is described on <a href=https://github.com/axboe/fio>its
GitHub page</a>. Execution is also not complicated, but it
requires preparation of the actual benchmark workload (workload is a set
of options describing how FIO will generate the traffic for
measurements). We&rsquo;ll see how workloads look for specific jobs below, but
first a few general rules:</p><ul><li>jobs should run on a time-based manner with ramp-up time to generate traffic
before the measurements (if <code>time_based</code> parameter is not set FIO will run until
requests transfer data of given size; duration of a job would be unpredictable),</li><li>numjobs parameter describes how many threads/processes FIO will spawn to do
the job. This is the place to scale your workload - you can use more or less
jobs to simulate wanted traffic and/or achieve wanted consumption level of
available CPU resources,</li><li>blocksize parameter tells how big chunks of data will be transferred; this
will influence bandwidth (bigger bs usually means higher BW, because there&rsquo;s
less requests and each request has its own overhead) and IOPS (lower bs usually
means higher IOPS, because smaller requests are completed faster and therefore
in a given unit of time more requests can be issued).
For details on available parameters and options go to <a href=https://github.com/axboe/fio/blob/master/HOWTO>HOWTO page</a>.</li></ul><p>FIO is generating I/O traffic using engines specific for the job. To specify
which engine is used in a job there&rsquo;s workload&rsquo;s option <code>ioengine=my_engine</code>.
All of them are described in <a href=https://github.com/axboe/fio/tree/master/engines>their c file</a> and all have corresponding
<a href=https://github.com/axboe/fio/tree/master/examples>examples</a>. Few of them are related to persistent memory:</p><p><strong>libpmem</strong></p><p>This engine reads/writes data using libpmem library. Works on a namespace
created in <code>fsdax</code> mode. Full example workload for generating traffic of
sequential reads using this engine can be found <a href=https://gist.github.com/lukaszstolarczuk/b358293ad818447f0f0388161bbaa332>here</a>. There are
additional comments within the jobfile to explain specific parameters.</p><p><strong>dev-dax</strong></p><p>It also uses libpmem library, but as the name suggest it is specified to work
with device-dax devices. Our full example workload <a href=https://gist.github.com/lukaszstolarczuk/d78d069eaedbe8e35024ef23fcaa5bed>DaxSeqR.fio</a>
shows how to properly use FIO with /dev/dax. Since we don&rsquo;t work on a &ldquo;regular&rdquo;
file we use a little trick to achieve more realistic measurements - we set a
separate space for each thread doing reads/writes using option
<code>offset_increment=(int)GB</code>. This way threads&rsquo; requests do not overlap each
other and results are not cached in the processor. In case FIO reads the same
part over and over (using different threads on the same space) it ends up not
reading from the device.</p><p><strong>pmemblk</strong></p><p><strong>Note:</strong>
This engine is no longer supported in the upstream version of FIO. Last version
of FIO supporting it is <code>fio-3.33</code>.</p><p>This engine is using libpmemblk library. Results delivered by this engine will
not show you the best performance of your hardware, only what this specific
library is capable of. While using this engine, <code>blocksize</code> and
<code>size</code> of a file are given as part of <code>filename</code> option, like here:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>filename<span style=color:#f92672>=</span>/mnt/pmem6/testjob,512,1024000
</span></span><span style=display:flex><span><span style=color:#75715e>#size=1024000M</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#bs=512</span>
</span></span></code></pre></div><p>This is a bit different approach, comparing with other engines which use
parameter &ldquo;bs&rdquo; and &ldquo;size&rdquo; (see commented part above). Full example workload
doing traffic of sequential reads for pmemblk can be found <a href=https://gist.github.com/lukaszstolarczuk/b97f2650a29233e7a8aa0dee26892339>here</a>.</p><p><strong>mmap</strong></p><p>It&rsquo;s the most &ldquo;basic&rdquo; of mentioned engines, because its purpose is just to read
from/write to a memory mapped region. It can be used with pmem, but is not
tailor-made. It generates traffic doing memcpy to/from memory region. Difference
between this engine and <code>libpmem</code> is that it doesn&rsquo;t use PMDK library and hence
doesn&rsquo;t take advantages of functions specific for writing to persistent memory.
Again, full example working workload is available: <a href=https://gist.github.com/lukaszstolarczuk/939a1241485d51ec7947ad9caf26d00b>MmapSeqR.fio</a></p><h3 id=execution-and-results>Execution and results</h3><p>Command to run FIO is: <code>fio [options] [jobfile] ...</code>.</p><p>Since we use workloads defined in a file (as opposed to specifying parameters
in command line), we execute FIO with command like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>numactl -N <span style=color:#ae81ff>0</span> fio --output<span style=color:#f92672>=</span>my_workload.json --output-format<span style=color:#f92672>=</span>json my_workload.fio
</span></span></code></pre></div><p><a href=https://linux.die.net/man/8/numactl>numactl command</a> guarantees that processes are pinned to selected
numa node. The same can also be achieved by assigning CPU mask for FIO using
option <code>cpus_allowed</code>. We chose JSON format to save our results in
it, for more convenient automatic parsing. Last parameter is our input file.</p><p>In the resulting file (here called my_workload.json) we look for a list
of [&ldquo;jobs&rdquo;] and then a section with the name of our job (&ldquo;jobname&rdquo;).
There is all the benchmark results that our simulated traffic has
delivered, including i.a. bw (bandwidth averaged per second, in kiB),
iops (IOPS count) and lat_ns (total latency in nanoseconds) divided into
read/write sub-sections and additional data like CPU usage (in %). For
details, please see &ldquo;Interpreting the output&rdquo; section in FIO&rsquo;s <a href=https://github.com/axboe/fio/blob/master/HOWTO#L3292>HOWTO
page</a> (you can look at &ldquo;normal&rdquo; output, since it has similar
attributes as in &ldquo;json&rdquo; formatted output).</p><h6 id=this-entry-was-edited-on-2018-09-03-to-update-one-of-the-ndctls-legacy-parameter-and-change-the-way-workloads-are-presented>[This entry was edited on 2018-09-03 to update one of the ndctl&rsquo;s legacy parameter and change the way workloads are presented.]</h6><h6 id=this-entry-was-edited-on-2023-03-03-to-mention-end-of-support-of-pmemblk-engine-in-fiohttpsgithubcomaxboefiopull1519>[This entry was edited on 2023-03-03 to mention <a href=https://github.com/axboe/fio/pull/1519>end of support of pmemblk engine in FIO</a>.]</h6><div class=clear></div><div class="si-share border-0 d-flex justify-content-between align-items-center"><span>Share this Post:</span><div id=share-buttons><div class="social-icon si-borderless si-facebook" title="Share this on Facebook" onclick='window.open("http://www.facebook.com/share.php?u=https://pmem.io/blog/2018/06/running-fio-with-pmem-engines/")'><i class=icon-facebook></i>
<i class=icon-facebook></i></div><div class="social-icon si-borderless si-twitter" title="Share this on Twitter" onclick='window.open("http://twitter.com/intent/tweet?text=Running FIO with pmem engines&url=https://pmem.io/blog/2018/06/running-fio-with-pmem-engines/")'><i class=icon-twitter></i>
<i class=icon-twitter></i></div><div class="social-icon si-borderless si-linkedin" title="Share this on Linkedin" onclick='window.open("https://www.linkedin.com/shareArticle?mini=true&url=https://pmem.io/blog/2018/06/running-fio-with-pmem-engines/&title=&summary=&source=")'><i class=icon-linkedin></i>
<i class=icon-linkedin></i></div><div class="social-icon si-borderless si-pinterest" title="Share this on Pinterest" onclick='window.open("https://pinterest.com/pin/create/button/?url=&media=&description=")'><i class=icon-pinterest></i>
<i class=icon-pinterest></i></div><div class="social-icon si-borderless si-email3" title="Share this through Email" onclick='window.open("mailto:?&body=https://pmem.io/blog/2018/06/running-fio-with-pmem-engines/")'><i class=icon-email3></i>
<i class=icon-email3></i></div></div></div></div></div><div class="row justify-content-between col-mb-30 post-navigation"><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2018/10/new-release-of-pmdk/?ref=footer">&lArr; New release of PMDK</a></div><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2018/05/using-persistent-memory-devices-with-the-linux-device-mapper/?ref=footer">Using Persistent Memory... &rArr;</a></div></div><div class=line></div><h4>Related Posts:</h4><div class="related-posts row posts-md col-mb-30"></div></div></div><div class="sidebar col-lg-3"><div class=sidebar-widgets-wrap><div class="widget clearfix"><h4>Tag Cloud</h4><div class=tagcloud><a href=/tags/pmem class=block role=button>pmem</a>
<a href=/tags/persistent-memory class=block role=button>persistent-memory</a>
<a href=/tags/ndctl class=block role=button>ndctl</a>
<a href=/tags/pmdk class=block role=button>pmdk</a>
<a href=/tags/cxl class=block role=button>cxl</a>
<a href=/tags/daxctl class=block role=button>daxctl</a>
<a href=/tags/memkind class=block role=button>memkind</a>
<a href=/tags/async class=block role=button>async</a>
<a href=/tags/asynchronous class=block role=button>asynchronous</a>
<a href=/tags/concurrency class=block role=button>concurrency</a>
<a href=/tags/configure class=block role=button>configure</a>
<a href=/tags/dax class=block role=button>dax</a>
<a href=/tags/install class=block role=button>install</a>
<a href=/tags/intro class=block role=button>intro</a>
<a href=/tags/miniasync class=block role=button>miniasync</a>
<a href=/tags/setup class=block role=button>setup</a>
<a href=/tags/dml class=block role=button>dml</a>
<a href=/tags/dsa class=block role=button>dsa</a>
<a href=/tags/faq class=block role=button>faq</a>
<a href=/tags/imdb class=block role=button>imdb</a>
<a href=/tags/memory class=block role=button>memory</a>
<a href=/tags/pmem-use-case class=block role=button>pmem-use-case</a>
<a href=/tags/pmem2 class=block role=button>pmem2</a>
<a href=/tags/sanitize class=block role=button>sanitize</a>
<a href=/tags/secure-erase class=block role=button>secure-erase</a>
<a href=/tags/sql class=block role=button>sql</a>
<a href=/tags/tiering class=block role=button>tiering</a>
<a href=/tags/2019 class=block role=button>2019</a>
<a href=/tags/blogs class=block role=button>blogs</a>
<a href=/tags/crash class=block role=button>crash</a></div></div></div></div></div></div></div></section><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2023 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>