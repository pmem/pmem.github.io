<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="Libpmemobj-cpp - lessons learned"><meta property="og:description" content="Introduction We&rsquo;ve been working on C++ bindings for libpmemobj since around 2016 - see our very first tutorial for libpmemobj-cpp. We&rsquo;ve come a long way since then. A lot has changed - we&rsquo;ve gained more experience and knowledge, added new features, fixed quite a few bugs, and created at least half a dozen new containers. It&rsquo;s fair to state this product is now far more mature and well-developed. Over time, we&rsquo;ve learned at least several lessons about designing and overcoming issues in C++ applications for persistent memory."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/blog/2021/09/libpmemobj-cpp-lessons-learned/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-09-30T00:00:00+00:00"><meta property="article:modified_time" content="2021-09-30T00:00:00+00:00"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>Libpmemobj-cpp - lessons learned</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=content><div class="content-wrap dark-mode"><div class="container clearfix"><div class="row gutter-40 col-mb-80"><div class="postcontent col-lg-9 order-lg-last"><div class="single-post mb-0"><div class="entry clearfix"><div class=entry-title><h2>Libpmemobj-cpp - lessons learned</h2></div><div class=entry-meta><ul><li><i class=icon-calendar3></i> 30 Sep, 2021</li><li><i class=icon-user></i> Lukaszstolarczuk</li><li><i class=icon-folder-open></i>
Libpmemobj-Cpp</li></ul></div><div class="entry-content mt-0"><h3 id=introduction>Introduction</h3><p>We&rsquo;ve been working on C++ bindings for <em>libpmemobj</em> since around 2016 - see our <a href=/2016/01/12/cpp-01.html>very first
tutorial for libpmemobj-cpp</a>. We&rsquo;ve come a long way since then. A lot has
changed - we&rsquo;ve gained more experience and knowledge, added new features, fixed quite a few
bugs, and created at least half a dozen new containers. It&rsquo;s fair to state this product is now
far more mature and well-developed. Over time, we&rsquo;ve learned at least several lessons about
designing and overcoming issues in C++ applications for persistent memory. We want to share
them with you to learn from <strong>our</strong> mistakes and not waste any time.</p><h3 id=design-problems>Design problems</h3><p>Designing efficient concurrent algorithms for persistent memory is a challenging task.
Actually, this is one of the reasons why we introduced libpmemobj-cpp in the first place.
We wanted to do the hard work once, test it as much as possible, and give people reliable,
efficient, ready-to-use solutions. We describe below only a few of our problems, which
we believe might benefit for a broader audience.</p><h4 id=optimize-number-of-allocations>Optimize number of allocations!</h4><p>Lots of allocations on pmem may ruin performance. It seems like an obvious statement, but
it&rsquo;s easy to overlook this issue. One badly placed allocation (e.g., in critical
code path), and we end up with low performance. Unfortunately, inserting a new node in
<code>pmem::obj::concurrent_hash_map</code> is associated with multiple allocations.
When we were thinking about the next container to implement, we chose radix tree structure.
It is a great fit for pmem, because it requires a minimal number of allocations, no tree
re-balancing, and it is sorted but requires no key comparisons. We realized
<code>pmem::obj::experimental::radix_tree</code> can be optimized even further. To store keys or
values of variable length, <code>string</code> (<code>pmem::obj::string</code> to be precise) is a natural
choice. Each such string means an extra allocation for the variable data.</p><p><img src=/images/posts/cpp_lessons_string.png alt="Radix tree with string" title="Radix tree with string"></p><ul><li><strong>Figure 1.</strong> Radix_tree with string - one extra allocation.</li></ul><p>As you can see in Figure 1. - there&rsquo;s <strong>one allocation for the <code>radix_tree</code> node</strong>
and <strong>one extra for the string data itself</strong>. To overcome this, we proposed an
<code>inline_string</code>, which keeps the actual data within the same allocation. In Figure 2.
below, you can see that all the data is held together: metadata, key
(right next to <code>inline_string</code> structure), and value.</p><p><img src=/images/posts/cpp_lessons_inline_string.png alt="Radix tree with inline_string" title="Radix tree with inline_string"></p><ul><li><strong>Figure 2.</strong> Radix_tree with inline_string - no extra allocations.</li></ul><p>We can see it&rsquo;s all done in one, slightly bigger allocation. There&rsquo;s a drawback! When
it comes to updating the string data, and the value is longer than the existing string
allocation - <strong>the whole node</strong> has to be re-allocated.</p><h4 id=using-per-thread-data>Using per-thread data</h4><p>Very recently, we&rsquo;ve described (<a href=/2021/09/17/concurrency.html>in the &ldquo;Concurrency considerations&rdquo; blog post</a>)
our approach to ensure data consistency. It&rsquo;s a very challenging task, especially if
you consider concurrent modifications within a container full of records, with multiple
threads accessing/modifying the same structure. Read the whole post for details,
but long story short - per-thread data (implemented in libpmemobj-cpp as
<a href=/libpmemobj-cpp/master/doxygen/classpmem_1_1detail_1_1enumerable__thread__specific.html>enumerable_thread_specific</a>) can save you from data consistency issues.</p><h4 id=keeping-locks-on-pmem-is-not-a-good-idea>Keeping locks on pmem is not a good idea</h4><p>Since we keep all data for our application on persistent memory, one might think we should
do that as well with locks. That&rsquo;s the wrong way. Each lock and unlock operation might end up
with a write to pmem. Even though we do not explicitly flush lock cache lines, they are
invalidated when a lock is accessed from a different core as part of ensuring coherency.
An additional write to pmem is, of course, undesired and limits the scalability of our data
structures. The solution is to move locks to DRAM instead. Only pointers to these locks
are held on persistent memory. Mentioned extra writes are less costly to DRAM than to pmem.
Currently, within our library, it is only possible with <code>concurrent_hash_map</code>. There are
two approaches, how we can use these locks:</p><ul><li><p>The first one is to keep per-element locks. It&rsquo;s a good fit when you store large
elements. With too many small objects, this approach may quickly exhaust available memory.</p></li><li><p>The second solution is to use sharding instead of per-element locks. Data can be divided
into multiple single-threaded buckets, each protected by a lock. This way will provide
a short waiting time on locks and good performance, but only with a uniform distribution of
elements and a big enough number of buckets. In practice, this can be easily implemented,
e.g., in unsorted data structures. It also means lower memory demand because of the lower
number of locked objects.</p></li></ul><h4 id=lazy-rehashing>Lazy rehashing</h4><p>A hash table, from time to time, has to perform a full rehashing of existing entries.
In a concurrent environment, this task is even more demanding and may require locking
the entire structure. With that approach, you will observe latency spikes in moments
of such rehashing, slowing down each new write to the structure. In our
<code>concurrent_hash_map</code> we introduced a &ldquo;lazy rehashing&rdquo; solution, based on the paper
<a href=https://arxiv.org/ftp/arxiv/papers/1509/1509.02235.pdf>&ldquo;Per-bucket concurrent rehashing algorithms&rdquo;</a>. When rehashing
is required, the number of buckets is doubled. Later, while accessing (in any way)
an element, it may be moved into some of the new buckets or may stay in place. With
this algorithm, rehashing happens one element at a time, not all at once. No global
locks are taken, only per bucket ones. Access is blocked to elements in the same
bucket, so the whole process does not significantly impact concurrency or structure&rsquo;s
performance. If you&rsquo;re curious, you can found all the algorithm&rsquo;s details in the
linked article.</p><h4 id=layout-compatibility>Layout compatibility</h4><p>By publishing a stable release of libpmemobj-cpp, we committed to a stable on-media layout.
From that point, we try and still promise that. We had a small hiccup on the way (in PMDK)
with pools compatibility, but we&rsquo;ve managed to fix that with the help of a tool now called
<a href=/2019/02/01/pool-conversion-tool.html>pmdk-convert</a>. Right now, we&rsquo;ve learned our lesson - we try to make the
layout extensible, but we know that <em>we don&rsquo;t know everything</em>. That&rsquo;s why, keeping in mind
future improvements, we save up some space for extensions in each structure. We&rsquo;ve also
introduced a mechanism for checking the compatibility - a <code>feature_flags</code>. Each time a data
structure, which implements feature flags, is used, we check it for compatibility. For example,
in <code>concurrent_hash_map</code> on each initialization, we call <code>check_incompat_features()</code> method,
and it throws an exception in case of any flags discrepancies. These flags can be used,
for example, to assert key/value size(s) or check the support of a certain feature.</p><h4 id=implementation-guidelines>Implementation guidelines</h4><p>Over time we encountered some issues failing our Continuous Integration testing scripts
and example apps. Sometimes though, something slipped our tests and CI process, and was
found by our users. We strive to make our tests as comprehensive as we can, but no process
is perfect. Years of experience provided us with small but good practices when designing
a new container or a method. We&rsquo;ve listed these in a
<a href=https://github.com/pmem/libpmemobj-cpp/blob/master/CONTRIBUTING.md#implementing-persistent-containers>practical guide for contributors</a>, which we follow every day.
The list is, naturally, not complete - we always look for something to improve.</p><h3 id=summary>Summary</h3><p>We hope it was helpful to read about all these challenges. You can learn from our mistakes,
not repeat them, and, hopefully, make good software using persistent memory. If you&rsquo;d like
to learn more, we&rsquo;ve shared some of these issues (and solutions) in the 2021 PMDK Summit
in a presentation titled <a href=/events/2021-spdk-pmdk-intel-performance-analyzers-virtual-forum/>&ldquo;State of Pmemkv&rdquo;</a>. Jump into that summit&rsquo;s
videos for more info about our projects. And don&rsquo;t forget we&rsquo;re open source. Do you have
ideas to improve our algorithms, extend this library, or just want to make a suggestion?
Please share - file an issue or simply open a pull request with your tweaks.</p><div class=clear></div><div class="si-share border-0 d-flex justify-content-between align-items-center"><span>Share this Post:</span><div id=share-buttons><div class="social-icon si-borderless si-facebook" title="Share this on Facebook" onclick='window.open("http://www.facebook.com/share.php?u=https://pmem.io/blog/2021/09/libpmemobj-cpp-lessons-learned/")'><i class=icon-facebook></i>
<i class=icon-facebook></i></div><div class="social-icon si-borderless si-twitter" title="Share this on Twitter" onclick='window.open("http://twitter.com/intent/tweet?text=Libpmemobj-cpp - lessons learned&url=https://pmem.io/blog/2021/09/libpmemobj-cpp-lessons-learned/")'><i class=icon-twitter></i>
<i class=icon-twitter></i></div><div class="social-icon si-borderless si-linkedin" title="Share this on Linkedin" onclick='window.open("https://www.linkedin.com/shareArticle?mini=true&url=https://pmem.io/blog/2021/09/libpmemobj-cpp-lessons-learned/&title=&summary=&source=")'><i class=icon-linkedin></i>
<i class=icon-linkedin></i></div><div class="social-icon si-borderless si-pinterest" title="Share this on Pinterest" onclick='window.open("https://pinterest.com/pin/create/button/?url=&media=&description=")'><i class=icon-pinterest></i>
<i class=icon-pinterest></i></div><div class="social-icon si-borderless si-email3" title="Share this through Email" onclick='window.open("mailto:?&body=https://pmem.io/blog/2021/09/libpmemobj-cpp-lessons-learned/")'><i class=icon-email3></i>
<i class=icon-email3></i></div></div></div></div></div><div class="row justify-content-between col-mb-30 post-navigation"><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2021/10/how-to-contribute-to-pmem.io/?ref=footer">&lArr; How to Contribute to pmem.io</a></div><div class="col-12 col-md-auto text-center"><a href="https://pmem.io/blog/2021/09/concurrency-considerations-in-libpmemobj-cpp/?ref=footer">Concurrency considerations in... &rArr;</a></div></div><div class=line></div><h4>Related Posts:</h4><div class="related-posts row posts-md col-mb-30"><div class="entry col-12 col-md-6"><div class="grid-inner row align-items-center gutter-20"><div class=col-4><div class=entry-image><a href=https://pmem.io/blog/2021/09/concurrency-considerations-in-libpmemobj-cpp/ data-lightbox=image><img src=/images/pmem_logo.png alt="Concurrency considerations in libpmemobj-cpp"></a></div></div><div class=col-8><div class="entry-title title-xs"><h3><a href=https://pmem.io/blog/2021/09/concurrency-considerations-in-libpmemobj-cpp/>Concurrency considerations in libpmemobj-cpp</a></h3></div><div class=entry-meta><ul><li><i class=icon-user></i> Igchor</li><li><i class=icon-calendar3></i> 17 Sep, 2021</li></ul></div></div></div></div><div class="entry col-12 col-md-6"><div class="grid-inner row align-items-center gutter-20"><div class=col-4><div class=entry-image><a href=https://pmem.io/blog/2019/02/c-persistent-containers-vector/ data-lightbox=image><img src=/images/pmem_logo.png alt="C++ persistent containers - vector"></a></div></div><div class=col-8><div class="entry-title title-xs"><h3><a href=https://pmem.io/blog/2019/02/c-persistent-containers-vector/>C++ persistent containers - vector</a></h3></div><div class=entry-meta><ul><li><i class=icon-user></i> Szyrom</li><li><i class=icon-calendar3></i> 20 Feb, 2019</li></ul></div></div></div></div><div class="entry col-12 col-md-6"><div class="grid-inner row align-items-center gutter-20"><div class=col-4><div class=entry-image><a href=https://pmem.io/blog/2018/11/c-persistent-containers/ data-lightbox=image><img src=/images/pmem_logo.png alt="C++ persistent containers"></a></div></div><div class=col-8><div class="entry-title title-xs"><h3><a href=https://pmem.io/blog/2018/11/c-persistent-containers/>C++ persistent containers</a></h3></div><div class=entry-meta><ul><li><i class=icon-user></i> Szyrom</li><li><i class=icon-calendar3></i> 20 Nov, 2018</li></ul></div></div></div></div><div class="entry col-12 col-md-6"><div class="grid-inner row align-items-center gutter-20"><div class=col-4><div class=entry-image><a href=https://pmem.io/blog/2018/11/c-persistent-containers-array/ data-lightbox=image><img src=/images/pmem_logo.png alt="C++ persistent containers - array"></a></div></div><div class=col-8><div class="entry-title title-xs"><h3><a href=https://pmem.io/blog/2018/11/c-persistent-containers-array/>C++ persistent containers - array</a></h3></div><div class=entry-meta><ul><li><i class=icon-user></i> Igchor</li><li><i class=icon-calendar3></i> 02 Nov, 2018</li></ul></div></div></div></div></div></div></div><div class="sidebar col-lg-3"><div class=sidebar-widgets-wrap><div class="widget clearfix"><h4>Tag Cloud</h4><div class=tagcloud><a href=/tags/pmem class=block role=button>pmem</a>
<a href=/tags/persistent-memory class=block role=button>persistent-memory</a>
<a href=/tags/ndctl class=block role=button>ndctl</a>
<a href=/tags/pmdk class=block role=button>pmdk</a>
<a href=/tags/cxl class=block role=button>cxl</a>
<a href=/tags/daxctl class=block role=button>daxctl</a>
<a href=/tags/memkind class=block role=button>memkind</a>
<a href=/tags/async class=block role=button>async</a>
<a href=/tags/asynchronous class=block role=button>asynchronous</a>
<a href=/tags/concurrency class=block role=button>concurrency</a>
<a href=/tags/configure class=block role=button>configure</a>
<a href=/tags/dax class=block role=button>dax</a>
<a href=/tags/install class=block role=button>install</a>
<a href=/tags/intro class=block role=button>intro</a>
<a href=/tags/miniasync class=block role=button>miniasync</a>
<a href=/tags/setup class=block role=button>setup</a>
<a href=/tags/dml class=block role=button>dml</a>
<a href=/tags/dsa class=block role=button>dsa</a>
<a href=/tags/faq class=block role=button>faq</a>
<a href=/tags/imdb class=block role=button>imdb</a>
<a href=/tags/memory class=block role=button>memory</a>
<a href=/tags/pmem-use-case class=block role=button>pmem-use-case</a>
<a href=/tags/pmem2 class=block role=button>pmem2</a>
<a href=/tags/sanitize class=block role=button>sanitize</a>
<a href=/tags/secure-erase class=block role=button>secure-erase</a>
<a href=/tags/sql class=block role=button>sql</a>
<a href=/tags/tiering class=block role=button>tiering</a>
<a href=/tags/2019 class=block role=button>2019</a>
<a href=/tags/blogs class=block role=button>blogs</a>
<a href=/tags/crash class=block role=button>crash</a></div></div></div></div></div></div></div></section><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2023 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>